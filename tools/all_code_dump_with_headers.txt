==================================================
PROJECT DUMP SUMMARY
==================================================
Dump generated on: 2025-05-26 16:04:10 WEST
Searched directory: /home/goteixei/42/project_repos/42_minishell/minishell
--------------------------------------------------
File Type Counts:
  C source files (.c):      97
  Header files (.h):        5
  Makefiles (Makefile*):    3
  ------------------------------------------------
  TOTAL files to be dumped: 105
--------------------------------------------------
Structure:
  Total directories scanned: 37
==================================================


--------------------------------------------------
FILE: ./../minishell/inc/minishell.h
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/17 16:47:25 by goteixei          #+#    #+#             */
/*   Updated: 2025/05/26 15:41:00 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

/**************************************************************************
 * SECTION: Libraries
 **************************************************************************/

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <fcntl.h>
# include <string.h>
# include <errno.h>
# include <limits.h>
# include <stdbool.h>

// signals
# include <signal.h>

// waitpid
# include <sys/wait.h> 

//stat/access???
# include <sys/stat.h>

// readline, add_history
# include <readline/readline.h>
# include <readline/history.h>

// non-standard librarys
# include "../lib/libft_repo/libft/libft.h"

/**************************************************************************
 * SECTION: Macros
 **************************************************************************/

// --- ANSI Color Codes ---
# define RESET   "\033[0m"
# define BLACK   "\033[0;30m"
# define RED     "\033[0;31m"
# define GREEN   "\033[0;32m"
# define YELLOW  "\033[0;33m"
# define BLUE    "\033[0;34m"
# define MAGENTA "\033[0;35m"
# define CYAN    "\033[0;36m"
# define WHITE   "\033[0;37m"

/**************************************************************************
 * SECTION: Structs
 **************************************************************************/

typedef enum e_token_type
{
	TOKEN_INFILE,				// 0 file
	TOKEN_OUTFILE,				// 1 outfile
	TOKEN_CMD,					// 2 commands
	TOKEN_PIPE,					// 3 |
	TOKEN_REDIR_IN,				// 4 <
	TOKEN_REDIR_OUT,			// 5 >
	TOKEN_APPEND,				// 6 >>
	TOKEN_HEREDOC,				// 7 <<
	TOKEN_EOF,					// 8 end of file
}	t_token_type;

typedef enum s_token_state
{
	GENERAL,					// 0 normal
	DOUBLE_QUOTES,				// 1 ""
	SIMPLE_QUOTES,				// 2 ''
}	t_token_states;

typedef struct s_token
{
	char					*value;
	t_token_type			type;
	t_token_states			state;
	bool					expand;
	int						*expand_index;
	struct s_token			*previous;
	struct s_token			*next;
}	t_token;

typedef struct s_ast
{
	t_token_type	type;
	char			**args;
	struct s_ast	*left;
	struct s_ast	*right;
}	t_ast;

/**
 * @brief Holds the main state of the minishell.
 *
 * @param environ_list    A dynamically allocated copy of the environment
 * variables
 *(char ** array, NULL-terminated, e.g., {"VAR=value", NULL}).
 *                        This is the list modified by export/unset.
 * @param last_exit_status The exit status of the most recently executed
 * foreground command ($?).
 * @param stdin_fd         Saved original standard input file descriptor
 * (usually 0).
 * @param stdout_fd        Saved original standard output file descriptor
 * (usually 1).
 * @param stderr_fd        Saved original standard error file descriptor
 * (usually 2).
 * @param shell_name       The name the shell was invoked with (argv[0]),
 * useful for errors.
 * @param current_cmd_table Pointer to the currently parsed command structure
 * (optional, can also be passed as function arguments).
 * Manage lifecycle carefully.
 * @param envp_orig        Pointer to the original envp from main
 * (optional, for reference).
 */
typedef struct s_minishell
{
	char	**envp;
	char	**paths;
	int		last_exit_status;
	int		stdin_fd;
	int		stdout_fd;
	int		stderr_fd;  
	char	*shell_name;
	char	**envp_orig;
}	t_minishell;

extern volatile sig_atomic_t g_signal;

/**************************************************************************
 * SECTION: Functions
 **************************************************************************/

// --- main ---
//void	ms_core_loop(char **envp);
//int	main(int argc, char **argv, char **envp);	

// --- prompt ---
char	*ms_get_prompt(t_minishell *data);

// --- debug ---
void	ms_debug_print_args(char **args);
void	ms_debug_print_gsig(void);

// --- init ---
int		init_shell_data(t_minishell *data, char **argv, char **envp);

// --- signals ---
void	ms_signal_handlers_init(void);
void	ms_signal_handlers_set_interactive(void);



// ------------------PARSER-------------------------
// ms_syntax_check.c
bool	ms_unclosed_quotes(char *input);
bool	ms_syntax_check(char *input);
bool	ms_pipes_placement(char *input);
bool	ms_rediractions_placement(char *input);
bool	ms_not_required (char *input);

//ms_syntax_utils.c
char	*ms_remove_whitespaces(char	 *input_line);
void	ms_skip_inside_quotes(int *i, char *input);
void	ms_skip_whitespaces(int *i, char *input);

//ms_tokenization.c
t_token	*ms_extract_quotes(char *input, int *i, t_token *list);
t_token	*ms_extract_cmd(char *input, int *i, t_token *list);
t_token	*ms_extract_file(char *input, int *i, t_token *list);
t_token	*ms_start_tokenization(char *input, t_token *list);
t_token	*ms_tokenization(char *input);

// ms_list_utils.c
t_token	*ms_last_node(t_token *list);
t_token	*ms_append_node(t_token *list, char  *input, t_token_type type);
void	ms_print_tokens(t_token *list);

//ms_tokenization_utils.c
int		ms_len_file(char *input, int i);
int		ms_len_cmd(char *input, int i);
int 	ms_quote_len(char *input, int i);
t_token	*ms_extract_operator(char *input, int *i, t_token *list);

//ms_tokenization_utils2.c
bool	ms_is_file(t_token	*list);
bool	ms_is_infile(t_token *list);
t_token	*ms_assign_state(t_token *list);
t_token	*ms_check_eof(t_token *list);

//ms_quotes.c
void	ms_normal_index(t_token *list);
int		*ms_put_index(t_token *list, int *index, int i, int k);
void	ms_quotes_index(t_token *list);
t_token	*ms_expansion_index(t_token *list);

//ms_quotes_utils.c
bool	ms_another_double(int i, char *value);
int		ms_count_normal(char *string);
int		ms_quotes_count(t_token	*list);

//ms_quotes_off.c
int		ms_new_size(char *value);
char	*ms_put_new(char *value, char *new_value);
t_token *ms_quotes_off(t_token *list);

// ms_main_parsing.c
void	ms_main_parsing(char *input, t_minishell *data);
void	print_indent(int level);
const char	*get_token_type_name(t_token_type type);
void	print_ast(t_ast *node, int level);

// ms_parsing.c
t_ast	*ms_parse_command(t_token **token);
t_ast	*ms_create_file_node(t_token *token);
t_ast	*ms_parse_redirection(t_token	**token_list);
t_ast	*ms_parse_pipes(t_token **token_list);
t_ast 	*ms_parse_tokens(t_token	**token_list);

// ms_parsing_utils.c
t_ast	*ms_new_ast_node(t_token_type type);
t_ast	*ms_create_and_link_redir(t_token **token_list, t_token *temp);

// ms_tree_exec.c
int		ms_exec_tree(t_ast *node, t_minishell *data);
int		ms_exec_cmd(t_ast *node, t_minishell *data);
int		ms_exec_pipe(t_ast *node, t_minishell *data);
int		ms_exec_redir_in(t_ast *node, t_minishell *data);
int		ms_exec_redir_out(t_ast	*node, t_minishell *data);
int		ms_exec_heredoc(t_ast *node, t_minishell *data);

// parsing placeholder 
void	ms_free_split_args(char **args);
char	**ms_parse_input_placeholder(const char *input_line);
int		ms_execute_command_placeholder(char **args, t_minishell *data);


// --------------------------------------------------------------------


// --- expand ---

// utils
int		ms_valid_var(char c, int mode);
int		ms_expand_error(char **args, int i, int mode);
int		ms_find_next_dollar(const char *str, int start_pos);
char	*ms_get_expansion_value(const char *info, int last_exit_status);
int		ms_append_and_free(char **base_str_ptr, const char *to_append);

// 2
char	*ms_process_simple_var_expansion(const char *str, int i, \
				int *t_len, int d_pos);
char	*ms_process_curly_expansion(const char *str, int i, \
				int *t_len, int d_pos);

// 1
//int		ms_process_one_expansion(const char *str, char **res_ptr, \
//				int *cur_pos_ptr, int dol_pos, int status);
//char	*ms_get_expansion_info(const char *str, int dollar_pos, \
//				int *target_len);
//int		ms_process_one_expansion(const char *str, char **res_ptr, \
//				int *cur_pos_ptr, int dol_pos, int status);
//char	*ms_expand_str_help(const char *original_str, int last_exit_status);
void	ms_expand_variables(char **args, int last_exit_status);

// --- built-ins ---
int		ms_execute_cd(char **args);
int		ms_execute_echo(char **args);
int		ms_execute_env(char **args, char **envp);
int		ms_execute_exit(char **args);
int		ms_execute_export(char **args, t_minishell *data);
int		ms_execute_pwd(char **args);
int		ms_execute_unset(char **args, t_minishell *data);

// --- exec ---
char	*ms_find_command_path(const char *cmd, char **envp);
int		ms_execute_external_command(char **args, char **envp);

#endif

--------------------------------------------------
FILE: ./../minishell/src/signals/ms_debug_global_signal.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_debug_global_signal.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 13:18:29 by goteixei          #+#    #+#             */
/*   Updated: 2025/05/26 14:25:29 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

//extern unsigned char	g_signal;

void	ms_debug_print_gsig(void)
{
	ft_printf(YELLOW "DEBUG g_signal = %d\n" RESET, (unsigned int)g_signal);
}


--------------------------------------------------
FILE: ./../minishell/src/signals/ms_signal_handlers.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_signal_handlers.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 16:37:50 by goteixei          #+#    #+#             */
/*   Updated: 2025/05/26 15:58:45 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

//unsigned char	g_signal;
//extern volatile sig_atomic_t g_signal;

/**
 * 
 * signum will be SIGINT
 * 
 * 1. Move to a new line. - write
 * 2. Tell readline we're on a new
 * 3. Clear the current input buffer.
 * 4. Redisplay the prompt and the (now empty) line.
 * 
 * rl_cleanup_after_signal tells readline to clean up
 * its internal state for signal handling.
 */
static void	ms_handle_sigint_interactive(int signum)
{
	(void)signum;

	g_signal = SIGINT;
	//ft_putstr_fd("HANDLER CALLED!\n", 2);
	//rl_cleanup_after_signal();
	write(STDOUT_FILENO, "\n", 1);
	rl_replace_line("", 0);
	rl_on_new_line();

	//rl_set_prompt(prompt_str); //optional

	rl_redisplay();
}


/**
 * SIGINT
 * SIGQUIT
 */
void	ms_signal_handlers_set_interactive(void)
{
	struct sigaction sa_int;
	struct sigaction sa_quit;

	sa_int.sa_handler = ms_handle_sigint_interactive;
	sigemptyset(&sa_int.sa_mask);
	//sa_int.sa_flags = SA_RESTART;
	if (sigaction(SIGINT, &sa_int, NULL) == -1)
	{
		perror("Minishell: Error setting SIGINT handler");
		exit(EXIT_FAILURE);
	}
	sa_quit.sa_handler = SIG_IGN;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	if (sigaction(SIGQUIT, &sa_quit, NULL) == -1)
	{
		perror("Minishell: Error setting SIGQUIT handler");
		exit(EXIT_FAILURE);
	}
}

/**
 * @brief Signal handler for SIGINT (Ctrl+C) in interactive mode.
 *
 * Action: Prints a newline, clears the current readline buffer,
 * redisplays the prompt, and sets the global exit status.
 * Based on readline's recommended way to handle signals.
 * @param sig The signal number (unused but required by signature).
 * 
 * rl_on_new_line, rl_replace_line, rl_redisplay are included in
 * readline/readline.h
 * 128 + sigint
 * 
 * 	//ft_putstr_fd("\n", STDOUT_FILENO);
 */
static void	ms_handle_sigint_init(int sig)
{
	(void)sig;
	g_signal = 128 + SIGINT;
	printf("\n");
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
}

/**
 * @brief Sets up the signal handlers for the main interactive loop.
 *
 * Configures SIGINT (Ctrl+C) to call handle_sigint_interactive.
 * Configures SIGQUIT (Ctrl+\) to be ignored (SIG_IGN).
 * Uses sigaction for more reliable signal handling.
 */
void	ms_signal_handlers_init(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_handler = ms_handle_sigint_init;
	sa_int.sa_flags = 0;
	if (sigaction(SIGINT, &sa_int, NULL) == -1)
	{
		perror("Error setting SIGINT handler");
		exit(EXIT_FAILURE);
	}
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_handler = SIG_IGN;
	sa_quit.sa_flags = 0;
	if (sigaction(SIGQUIT, &sa_quit, NULL) == -1)
	{
		perror("Error setting SIGQUIT handler");
		exit(EXIT_FAILURE);
	}
}


--------------------------------------------------
FILE: ./../minishell/src/builtin/ms_execute_cd.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_cd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 17:32:46 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 18:45:33 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * static int	ms_cd_error(char *msg, char *details)
{	
	//todo create ft_fprintf
	//fprintf(stderr, "minishell: cd: %s", msg);
	//if (details)
	//{
	//	fprintf(stderr, ": %s", details);
	//}
	//fprintf(stderr, "\n");
	ft_putstr_fd("minishell: cd: ", 2);
	ft_putstr_fd(msg, 2);
	if (details)
	{
		ft_putstr_fd(": ", 2);
		ft_putstr_fd(details, 2);
	}
	ft_putstr_fd(details, 2);
	return (1);
}
 */

/**
 * @brief Prints an error message for cd to standard error.
 * @param msg The specific error message.
 * @param details Optional details (like the directory name). Can be NULL.
 * @return Always returns 1 (failure exit status for cd).
 */
static int	ms_cd_error(char *msg, char *details)
{
	ft_putstr_fd("minishell: cd: ", 2);
	ft_putstr_fd(msg, 2);
	if (details)
	{
		ft_putstr_fd(": ", 2);
		ft_putstr_fd(details, 2);
	}
	ft_putstr_fd(details, 2);
	return (1);
}

/**
 * @brief Executes the 'cd' built-in command.
 * Changes the current working directory. Handles 'cd' and 'cd <path>'.
 * Does NOT update PWD/OLDPWD environment variables in this simple version.
 * @param args Argument vector. args[0] is "cd", args[1] (optional) is 
 * the target directory.
 * @return 0 on success, 1 on failure.
 * 
 * Part 1: Check arguments
 * Part 2: Change directory
 */
int	ms_execute_cd(char **args)
{
	char	*target_dir;

	if (args[1] == NULL)
	{
		target_dir = getenv("HOME");
		if (target_dir == NULL)
			return (ms_cd_error("HOME not set", NULL));
	}
	else
	{
		if (args[2] != NULL)
		{
			return (ms_cd_error("too many arguments", NULL));
		}
		target_dir = args[1];
	}
	if (chdir(target_dir) == -1)
	{
		char error_prefix[1024];
		snprintf(error_prefix, sizeof(error_prefix), \
		"minishell: cd: %s", target_dir);
		perror(error_prefix);
		return (1);
	}
	//TODO PWD OLDPWD
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/src/builtin/ms_execute_echo.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_echo.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 17:32:50 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 18:43:30 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief Executes the echo builtin command using a simple argv array.
 *
 * Prints arguments to standard output. Handles the -n option
 * to suppress the trailing newline.
 *
 * @param args A NULL-terminated array of strings representing the command
 *             and its arguments (e.g., {"echo", "-n", "hello", NULL}).
 *             args[0] is expected to be "echo".
 * @return int Always returns 0 (success) for echo.
 * 
 * 1: Check for existance of args
 * 2: -n flag
 * 3: print the arguments (can be more than one with ' ' between them)
 * 
 * -n suppresses the trailing newline character.
 */
int	ms_execute_echo(char **args)
{
	int	i;
	int	print_newline;

	i = 1;
	print_newline = 1;
	if (args[1] == NULL)
		return (ft_putchar_fd('\n', STDOUT_FILENO), 0);
	if (ft_strncmp(args[1], "-n", 3) == 0)
	{
		print_newline = 0;
		i = 2;
	}
	while (args[i] != NULL)
	{
		ft_putstr_fd(args[i], STDOUT_FILENO);
		if (args[i + 1] != NULL)
		{
			ft_putchar_fd(' ', STDOUT_FILENO);
		}
		i++;
	}
	if (print_newline)
		ft_putchar_fd('\n', STDOUT_FILENO);
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/src/builtin/ms_execute_env.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_env.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 00:20:09 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 18:43:43 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief Executes the env builtin command.
 *
 * Prints all environment variables passed via envp that contain an '='.
 * Currently ignores any arguments passed to the 'env' command itself.
 *
 * @param args The command arguments array (args[0] is "env"). Currently unused.
 * @param envp The environment variables array.
 * @return int Always returns 0 (success).
 */
int	ms_execute_env(char **args, char **envp)
{
	int	i;

	(void)args;
	i = 0;
	if (args[1] != NULL)
	{
		ft_putstr_fd("env: too many arguments\n", STDERR_FILENO);
		return (1);
	}
	while (envp && envp[i] != NULL)
	{
		if (ft_strchr(envp[i], '=') != NULL)
		{
			ft_putstr_fd(envp[i], STDOUT_FILENO);
			ft_putchar_fd('\n', STDOUT_FILENO);
		}
		i++;
	}
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/src/builtin/ms_execute_exit.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_exit.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/08 23:10:39 by goteixei          #+#    #+#             */
/*   Updated: 2025/05/26 14:25:52 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

//extern unsigned char	g_signal;

//todo implement in libft
static bool	ft_isspace(char c)
{
	return (c == ' ' || c == '\t' || c == '\n' || \
			c == '\v' || c == '\f' || c == '\r');
}

/**
 * @brief Attempts to convert a string to a long long, checking for validity.
 *        Checks for overflow and ensures the entire string represents a number
 *        (allowing optional leading '+' or '-').
 * @param str The string to convert.
 * @param n_out Pointer where the resulting long long will be stored if valid.
 * @return true if the string is a valid representation of a long long,
 *         false otherwise (overflow, non-digit characters).
 * 
 * ft_isdigit -> must have at least one digit
 * second ft_isspace -> check for trailing spaces
 * before multiplying or adding we check that the result * 10 won't overflow
 */
bool	ft_atol_validate(const char *str, long long *n_out)
{
	long long	result;
	int			sign;
	int			i;

	result = 0;
	sign = 1;
	i = 0;
	while (ft_isspace(str[i]))
		i++;
	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	if (!ft_isdigit(str[i]))
		return (false);
	while (ft_isdigit(str[i]))
	{
		if (sign == 1 && (result > LLONG_MAX / 10 || \
			(result == LLONG_MAX / 10 && (str[i] - '0') > LLONG_MAX % 10)))
			return (false);
		if (sign == -1 && (result > LLONG_MAX / 10 || \
			(result == LLONG_MAX / 10 && (str[i] - '0') > LLONG_MAX % 10 + 1)))
			return (false);
		result = result * 10 + (str[i] - '0');
		i++;
	}
	while (ft_isspace(str[i]))
		i++;
	if (str[i] != '\0')
		return (false);
	*n_out = sign * result;
	return (true);
}

/**
 * @brief Executes the exit builtin command.
 *
 * Terminates the shell process with a specified status or the status
 * of the last command. Handles errors for non-numeric or too many args.
 *
 * @param args The command arguments array (args[0] is "exit").
 * @param last_exit_status The exit status of the previously executed command.
 * @return int Returns 1 if there are too many arguments (and doesn't exit),
 *             otherwise, it calls exit() and does not return.
 * 
 * 1 Count arguments
 * 2 Print exit
 * 3 If only one argument
 * 4 2 aarguments, either valid or non numeric
 * 5 Too many arguments
 */
int	ms_execute_exit(char **args)
{
	int			argc;
	long long	exit_code_ll;

	argc = 0;
	while (args[argc] != NULL)
		argc++;
	ft_putstr_fd("exit\n", STDERR_FILENO);
	if (argc == 1)
	{
		exit(g_signal);
	}
	else if (argc == 2)
	{
		if (ft_atol_validate(args[1], &exit_code_ll))
		{
			exit((unsigned char)exit_code_ll);
		}
		else
		{
			ft_putstr_fd("minishell: exit: ", STDERR_FILENO);
			ft_putstr_fd(args[1], STDERR_FILENO);
			ft_putstr_fd(": numeric argument required\n", STDERR_FILENO);
			exit(255);
		}
	}
	else
	{
		ft_putstr_fd("minishell: exit: too many arguments\n", STDERR_FILENO);
		return (1);
	}
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/src/builtin/ms_execute_export.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_export.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 01:33:50 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/28 12:19:31 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

//todo needs linkedlist?

//todo repeat function, merge them and send it to utils
static int	ms_is_valid_identifier(const char *str)
{
	int	i;

	if (!str || str[0] == '\0' || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (0);
	i = 1;
	while (str[i])
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

//todo find_env_var_index (reuse or copy from unset)
// Check if the entry starts with "name="
static int	find_env_var_index(const char *name, size_t name_len, \
		char **env_list)
{
	int	i;

	i = 0;
	if (!name || !env_list)
		return (-1);
	while (env_list[i])
	{
		if (ft_strncmp(env_list[i], name, name_len) == 0 \
			&& env_list[i][name_len] == '=')
		{
			return (i);
		}
		i++;
	}
	return (-1);
}

// Prints the "not a valid identifier" error message for export.
static void	print_export_invalid_identifier_err(const char *arg)
{
	ft_putstr_fd("minishell: export: `", STDERR_FILENO);
	ft_putstr_fd((char *)arg, STDERR_FILENO);
	ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
}

// Extracts the variable name part from an export argument (e.g., "VAR=" -> "VAR").
// Returns an allocated string for the name, or NULL on allocation failure or if arg is NULL.
// Also sets name_len via the pointer.
static char	*extract_var_name(const char *arg, size_t *len_name)
{
	char *equal_sign;
	char *name;

	if (!arg) return (NULL);

	equal_sign = ft_strchr(arg, '=');
	if (equal_sign)
		*len_name = equal_sign - arg;
	else
		*len_name = ft_strlen(arg);
	name = (char *)malloc(sizeof(char) * (*len_name + 1));
	if (!name)
	{
		perror("minishell: export: malloc error extracting name");
		return (NULL);
	}
	ft_strlcpy(name, arg, *len_name + 1);
	name[*len_name] = '\0';
	return (name);
}

// Needed by add_or_update_env_var
static int	add_new_env_var(t_minishell *data, const char *new_var_str)
{
	int     count = 0;
	char    **new_environ;
	char    *var_copy;
	int     i;

	if (data->envp) {
		while (data->envp[count])
			count++;
	}

	new_environ = (char **)malloc(sizeof(char *) * (count + 2));
	if (!new_environ) {
		perror("minishell: export: malloc error for new env list");
		return (1);
	}

	for (i = 0; i < count; i++) {
		new_environ[i] = data->envp[i];
	}

	var_copy = ft_strdup(new_var_str);
	if (!var_copy) {
		perror("minishell: export: ft_strdup error for new var");
		free(new_environ);
		return (1);
	}

	new_environ[count] = var_copy;
	new_environ[count + 1] = NULL;

	if (data->envp) {
		free(data->envp);
	}
	data->envp = new_environ;
	return (0);
}

// Needed by add_or_update_env_var
static int	update_existing_env_var(t_minishell *data, int index, const char *new_var_str)
{
	char *var_copy;

	var_copy = ft_strdup(new_var_str);
	if (!var_copy) {
		perror("minishell: export: ft_strdup error updating var");
		return (1);
	}
	free(data->envp[index]);
	data->envp[index] = var_copy;
	return (0);
}

// Definition for the function causing the second error
static int	add_or_update_env_var(t_minishell *data, const char *arg)
{
	char	*name;
	size_t	name_len;
	int		index;
	int		status;

	name = extract_var_name(arg, &name_len);
	if (!name) return (1);

	if (!ms_is_valid_identifier(name))
	{
		print_export_invalid_identifier_err(arg);
		free(name);
		return (1);
	}

	index = find_env_var_index(name, name_len, data->envp);

	if (index != -1) {
		status = update_existing_env_var(data, index, arg);
	} else {
		status = add_new_env_var(data, arg);
	}

	free(name);
	return (status);
}

// Definition for the function causing the first error
static int	print_exported_vars(t_minishell *data)
{
	int		i;
	int		j;
	int		count;
	char	**env_copy = NULL;
	char	*temp;
	char	*value_ptr;

	i = 0;
	j = 0;
	count = 0;
	if (data->envp)
	{
		while (data->envp[count])
			count++;
	}
	if (count == 0)
		return (0);
	env_copy = (char **)malloc(sizeof(char *) * (count + 1));
	if (!env_copy)
	{
		perror("minishell: export: malloc error for env copy");
		return (1);
	}
	for (i = 0; i < count; i++)
	{
		env_copy[i] = ft_strdup(data->envp[i]);
		if (!env_copy[i])
		{
			perror("minishell: export: ft_strdup error for env copy entry");
			while (--i >= 0) free(env_copy[i]);
			free(env_copy);
			return (1);
		}
	}
	env_copy[count] = NULL;
	for (i = 0; i < count - 1; i++)
	{
		for (j = 0; j < count - i - 1; j++)
		{
			if (strcmp(env_copy[j], env_copy[j + 1]) > 0)
			{
				temp = env_copy[j];
				env_copy[j] = env_copy[j + 1];
				env_copy[j + 1] = temp;
			}
		}
	}
	for (i = 0; i < count; i++)
	{
		ft_putstr_fd("declare -x ", STDOUT_FILENO);
		value_ptr = ft_strchr(env_copy[i], '=');
		if (value_ptr)
		{
			write(STDOUT_FILENO, env_copy[i], value_ptr - env_copy[i]);
			ft_putstr_fd("=\"", STDOUT_FILENO);
			char *val = value_ptr + 1;
			while(*val) {
				if (*val == '"' || *val == '$' || *val == '\\')
					ft_putchar_fd('\\', STDOUT_FILENO);
				ft_putchar_fd(*val, STDOUT_FILENO);
				val++;
			}
			ft_putstr_fd("\"", STDOUT_FILENO);
		} else
			ft_putstr_fd(env_copy[i], STDOUT_FILENO);
		ft_putstr_fd("\n", STDOUT_FILENO);
	}
	for (i = 0; i < count; i++)
	{
		free(env_copy[i]);
	}
	free(env_copy);
	return (0);
}

/**
 * @brief Exports variables to the environment or prints exported variables.
 * @param args Command arguments, args[0] = "export", args[1..n] = assignments.
 * @param data Pointer to the main shell data structure.
 * @return int 0 on success, 1 if any identifier was invalid or allocation failed.
 * 
 * 1 Export with no arguments
 * 2 Export with arguments
 * 2.1 Extract name
 * 2.2 Handle memory error and format
 * 2.3 Validate identifier
 * 2.4 Check if there is an assignment (contains '=')
 */
int	ms_execute_export(char **args, t_minishell *data)
{
	int			i;
	int			exit_status;
	char		*var_name;
	size_t		name_len;
	int			op_status;

	exit_status = 0;
	i = 1;
	if (args[i] == NULL)
		return (print_exported_vars(data));
	while (args[i])
	{
		var_name = extract_var_name(args[i], &name_len);
		if (!var_name || name_len == 0)
		{
			print_export_invalid_identifier_err(args[i]);
			exit_status = 1;
			i++;
			continue;
		}
		if (!ms_is_valid_identifier(var_name))
		{
			print_export_invalid_identifier_err(args[i]);
			exit_status = 1;
			free(var_name);
		}
		else if (ft_strchr(args[i], '=') != NULL)
		{
			free(var_name);
			var_name = NULL;
			op_status = add_or_update_env_var(data, args[i]);
			if (op_status != 0)
				exit_status = 1;
		}
		else
			free(var_name);
		i++;
	}
	return (exit_status);
}



--------------------------------------------------
FILE: ./../minishell/src/builtin/ms_execute_pwd.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_pwd.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 18:24:59 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/07 18:33:13 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief Executes the 'pwd' built-in command.
 * Gets the current path using getcwd and prints it.
 * @param args Argument vector. Checks if too many args are provided.
 * @return 0 on success, 1 on failure.
 * 
 * Part 1: Check args
 * Part 2: Get current working directory
 * Part 3: Print the path to the std output
 * Part 4: Free buffer
 * Part 5: Return value
 */
int	ms_execute_pwd(char **args)
{
	char	*cwd_buffer;

	if (args[1] != NULL)
	{
		ft_putstr_fd("minishell: pwd: too many arguments\n", 2);
		return (1);
	}
	cwd_buffer = getcwd(NULL, 0);
	if (cwd_buffer == NULL)
	{
		perror("minishell: pwd");
		return (1);
	}
	ft_putstr_fd(cwd_buffer, 1);
	ft_putstr_fd("\n", 1);
	free(cwd_buffer);
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/src/builtin/ms_execute_unset.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_unset.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 17:31:46 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/26 17:59:49 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief Checks if a string is a valid POSIX identifier.
 *        Starts with '_' or an alphabet char.
 *        Contains only '_', alphabet chars, or digits.
 * @param str The string to check.
 * @return 1 if valid, 0 otherwise.
 * 
 * is alnum - alphanumeric
 */
static int	ms_valid_identifier(const char *str)
{
	int	i;

	if (!str || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (0);
	i = 1;
	while (str[i])
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

/**
 * @brief Prints the unset error message for an invalid identifier.
 * @param arg The invalid identifier string.
*/
static void	ms_print_invalid_identifier_err(const char *arg)
{
	ft_putstr_fd("minishell: unset: `", STDERR_FILENO);
	ft_putstr_fd((char *)arg, STDERR_FILENO);
	ft_putstr_fd("': not a valid identifier\n", STDERR_FILENO);
}

/**
 * @brief Finds the index of an environment variable in the list.
 *        Matches 'name=' at the beginning of an entry.
 * @param name The variable name to search for.
 * @param env_list The NULL-terminated environment list.
 * @return The index if found, -1 otherwise.
*/
static int	ms_find_env_var_index(const char *name, char **env_list)
{
	int		i;
	size_t	name_len;

	if (!name || !env_list)
		return (-1);
	name_len = ft_strlen(name);
	i = 0;
	while (env_list[i])
	{
		if (ft_strncmp(env_list[i], name, name_len) == 0
			&& env_list[i][name_len] == '=')
		{
			return (i);
		}
		i++;
	}
	return (-1);
}

/**
 * @brief Removes an environment variable at a specific index in-place.
 *        Frees the string at the index and shifts subsequent pointers left.
 * @param index The index of the variable to remove.
 * @param data The main data structure containing the environ_list.
 * 
 * 1. Free the string ("KEY=VALUE") being removed
 * 2. Shift all subsequent pointers one position down (left)
 * 3. Set the last valid position (which now holds a duplicated pointer)
 *  to NULL to properly terminate the list.
*/
static void	ms_remove_env_var_at_index(int index, t_minishell *data)
{
	int	i;

	free(data->envp[index]);
	data->envp[index] = NULL;
	i = index;
	while (data->envp[i + 1])
	{
		data->envp[i] = data->envp[i + 1];
		i++;
	}
	data->envp[i] = NULL;
}

/**
 * @brief Executes the unset builtin command.
 *        Removes specified environment variables.
 * @param args Command arguments (args[0] is "unset").
 * @param data The main data structure containing the environ_list.
 * @return Exit status: 0 on success, 1 if any identifier was invalid.
*/
int	ms_execute_unset(char **args, t_minishell *data)
{
	int		i;
	int		exit_status;
	int		var_index;
	char	*var_name;

	exit_status = 0;
	i = 1;
	while (args[i])
	{
		var_name = args[i];
		if (!ms_valid_identifier(var_name))
		{
			ms_print_invalid_identifier_err(var_name);
			exit_status = 1;
		}
		else
		{
			var_index = ms_find_env_var_index(var_name, data->envp);
			if (var_index != -1)
				ms_remove_env_var_at_index(var_index, data);
		}
		i++;
	}
	return (exit_status);
}


--------------------------------------------------
FILE: ./../minishell/src/exec/ms_exec_external.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_exec_external.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 02:05:03 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 18:00:58 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

// This function runs in the child process.
// It attempts to execute the command. If execve fails, it prints an error
// and exits the child process with an appropriate status code.

//eacces
//enoent
//126 permission denied
//127 command not found
static void	ms_child_exec(const char *path, char **args, char **envp)
{
	execve(path, args, envp);
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(args[0], STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putstr_fd(strerror(errno), STDERR_FILENO);
	ft_putstr_fd("\n", STDERR_FILENO);
	if (errno == EACCES)
		exit(126);
	if (errno == ENOENT)
		exit(127);
	exit(EXIT_FAILURE);
}

// This function runs in the parent process.
// It waits for the child process (pid) to finish and returns its exit status.
/**
 * 	Check how the child terminated
	if (WIFEXITED(status))
	{
		Child exited normally, return its exit code
		exit_status = WEXITSTATUS(status);
	}
 */
static int	ms_parent_wait(pid_t pid)
{
	int	status;
	int	exit_status;

	if (waitpid(pid, &status, 0) == -1)
	{
		perror("minishell: waitpid");
		return (1);
	}
	if (WIFEXITED(status))
	{
		exit_status = WEXITSTATUS(status);
	}
	else if (WIFSIGNALED(status))
	{
		exit_status = 128 + WTERMSIG(status);
	}
	else
	{
		exit_status = 1;
	}
	return (exit_status);
}

static int	ms_execute_error(char **args, int mode)
{
	if (mode == 1)
	{
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putstr_fd(args[0], STDERR_FILENO);
		ft_putstr_fd(": Permission denied\n", STDERR_FILENO);
		return (126);
	}
	else if (mode == 2)
	{
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putstr_fd(args[0], STDERR_FILENO);
		ft_putstr_fd(": No such file or directory\n", STDERR_FILENO);
		return (127);
	}
	else
	{
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putstr_fd(args[0], STDERR_FILENO);
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
		return (127);
	}
}

static void	ms_child_exec_help(char **args, char **envp, char *path)
{
	ms_child_exec(path, args, envp);
	free(path);
	exit(EXIT_FAILURE);
}

/**
 * @brief Executes an external command found in PATH.
 *        Handles fork, execve, and waiting for the child.
 * @param args The command arguments array (args[0] is the command).
 * @param envp The environment array.
 * @return The exit status of the executed command, or error codes
 *         (e.g., 127 for not found, 1 for fork/wait errors).
 * 
 * 1 Check args
 * 2 Find path and check if it exists
 * 3 fork
 * 4 if fork fails
 * 5 if child
 * 6 if parent
 */
int	ms_execute_external_command(char **args, char **envp)
{
	char	*path;
	pid_t	pid;

	if (!args || !args[0])
		return (0);
	path = ms_find_command_path(args[0], envp);
	if (!path)
	{
		if (ft_strchr(args[0], '/') && errno == EACCES)
			return (ms_execute_error(args, 1));
		else if (ft_strchr(args[0], '/') && errno == ENOENT)
			return (ms_execute_error(args, 2));
		else
			return (ms_execute_error(args, 3));
	}
	pid = fork();
	if (pid == -1)
		return (perror("minishell: fork"), free(path), 1);
	else if (pid == 0)
		ms_child_exec_help(args, envp, path);
	else
		return (free(path), ms_parent_wait(pid));
	return (1);
}


--------------------------------------------------
FILE: ./../minishell/src/exec/ms_path_handler.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_path_handler.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/09 02:04:44 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 18:18:58 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

// Helper function to free the array returned by ft_split
static void	ms_free_paths(char **paths)
{
	int	i;

	i = 0;
	if (!paths)
		return ;
	while (paths[i])
	{
		free(paths[i]);
		i++;
	}
	free(paths);
}

// Helper function to join directory and command name safely
static char	*ms_join_path(const char *dir, const char *cmd)
{
	char	*tmp;
	char	*full_path;

	if (dir && dir[0] != '\0')
		tmp = ft_strjoin(dir, "/");
	else
		tmp = ft_strdup("");
	if (!tmp)
	{
		perror("minishell: join_path (strdup/strjoin)");
		return (NULL);
	}
	full_path = ft_strjoin(tmp, cmd);
	free(tmp);
	if (!full_path)
	{
		perror("minishell: join_path (strjoin)");
		return (NULL);
	}
	return (full_path);
}

static char	*ms_get_path_variable(char **envp)
{
	int	i;

	i = 0;
	while (envp && envp[i])
	{
		if (ft_strncmp(envp[i], "PATH=", 5) == 0)
		{
			return (envp[i] + 5);
		}
		i++;
	}
	return (NULL);
}

static char	*ms_find_command_path_help(const char *cmd, char **envp)
{
	char	*path_env_value;

	if (!cmd || cmd[0] == '\0')
		return (NULL);
	if (ft_strchr(cmd, '/'))
	{
		if (access(cmd, F_OK) == 0)
		{
			if (access(cmd, X_OK) == 0)
				return (ft_strdup(cmd));
			else
				errno = ENOENT;
		}
		else
			errno = ENOENT;
		return (NULL);
	}
	path_env_value = ms_get_path_variable(envp);
	if (!path_env_value)
		return (NULL);
	return (path_env_value);
}

/**
 * @brief Finds the full path of a command using the PATH environment variable.
 * @param cmd The command name (e.g., "ls").
 * @param envp The environment array.
 * @return Allocated string containing the full path if found and executable,
 *         NULL otherwise (or on error).
 *         The caller must free the returned string.
 * 
 * 1 Handle absolute paths
 * 2 Find PATH variable in PATH
 * 3 Split PATH variable into directories
 * 4 Iterate through directories and check the command
 * 5 Command not found in any PATH directory
 * 
 * F_OK - exists and is executable
 * X_OK
 */
char	*ms_find_command_path(const char *cmd, char **envp)
{
	char	*path_info;
	char	**paths;
	char	*full_path;
	int		i;

	path_info = ms_find_command_path_help(cmd, envp);
	if (!path_info)
		return (NULL);
	if (ft_strchr(cmd, '/'))
		return (path_info);
	paths = ft_split(path_info, ':');
	if (!paths)
		return (perror("minishell: ft_split (PATH)"), NULL);
	i = 0;
	while (paths[i])
	{
		full_path = ms_join_path(paths[i], cmd);
		if (!full_path)
			return (ms_free_paths(paths), NULL);
		if (access(full_path, X_OK) == 0)
			return (ms_free_paths(paths), full_path);
		free(full_path);
		i++;
	}
	return (ms_free_paths(paths), NULL);
}


--------------------------------------------------
FILE: ./../minishell/src/init/ms_init_struct.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_init_struct.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 18:19:19 by goteixei          #+#    #+#             */
/*   Updated: 2025/05/21 14:05:23 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h" // Adjust path as needed

char **get_path(char **envp)
{
	int		i;
	char	**paths;

	i = 0;
	while (envp[i])
	{
		if (ft_strncmp(envp[i], "PATH=", 5) == 0)
		{
			paths = ft_split(envp[i] + 5, ':');
			return (paths);
		}
		i++;
	}
	ft_putstr_fd("Path variable not found", 2);
	exit(EXIT_FAILURE);
}

/**
 * @brief Frees the memory allocated for a duplicated environment list.
 *        Handles NULL input gracefully.
 * @param envp_copy The char** list to free.
 */
void	free_envp_copy(char **envp_copy)
{
	int	i;

	if (!envp_copy)
		return ;
	i = 0;
	while (envp_copy[i])
	{
		free(envp_copy[i]);
		i++;
	}
	free(envp_copy);
}

/**
 * @brief Duplicates the environment variable array (deep copy).
 *        Handles allocation errors.
 * @param envp The original environment array from main. Can be NULL.
 * @return A newly allocated, NULL-terminated copy of envp, or NULL on failure.
 *         Returns an allocated array containing only NULL if envp is
 * NULL or empty.
 */
char	**duplicate_envp(char **envp)
{
	int		i;
	int		count;
	char	**copy;

	count = 0;
	if (envp)
	{
		while (envp[count])
			count++;
	}
	copy = (char **)malloc(sizeof(char *) * (count + 1));
	if (!copy)
	{
		perror("minishell: malloc error duplicating envp");
		return (NULL);
	}
	i = 0;
	while (i < count)
	{
		copy[i] = ft_strdup(envp[i]);
		if (!copy[i])
		{
			perror("minishell: ft_strdup error duplicating envp entry");
			free_envp_copy(copy);
			return (NULL);
		}
		i++;
	}
	copy[i] = NULL;
	return (copy);
}

/**
 * @brief Initializes the main shell data structure.
 *
 * @param data Pointer to the t_data struct to initialize.
 * @param argv The argument vector from main (for shell_name).
 * @param envp The environment variables from main.
 * @return 0 on success, 1 on failure (e.g., memory allocation, dup error).
 * 
 * 1. Initialize pointers to NULL first for safety in cleanup
 * 2. Duplicate environment variables
 * 3. Initialize exit status
 * 4. Save original standard I/O file descriptors using dup()
 * 5. Store shell name (duplicate it)
 * 6. Store pointer to original envp (no allocation needed)
 */
int	init_shell_data(t_minishell *data, char **argv, char **envp)
{
	if (!data || !argv)
		return (1);
	data->envp = NULL;
	data->shell_name = NULL;
	data->stdin_fd = -1;
	data->stdout_fd = -1;
	data->stderr_fd = -1;
	data->envp = duplicate_envp(envp);
	if (!data->envp)
		return (1);
	data->paths = get_path(envp);
	data->last_exit_status = 0;
	data->stdin_fd = dup(STDIN_FILENO);
	if (data->stdin_fd == -1)
	{
		perror("minishell: dup(STDIN_FILENO)");
		free_envp_copy(data->envp);
		return (1);
	}
	data->stdout_fd = dup(STDOUT_FILENO);
	if (data->stdout_fd == -1)
	{
		perror("minishell: dup(STDOUT_FILENO)");
		free_envp_copy(data->envp);
		close(data->stdin_fd);
		return (1);
	}
	data->stderr_fd = dup(STDERR_FILENO);
	if (data->stderr_fd == -1)
	{
		perror("minishell: dup(STDERR_FILENO)");
		free_envp_copy(data->envp);
		close(data->stdin_fd);
		close(data->stdout_fd);
		return (1);
	}
	if (argv[0])
		data->shell_name = ft_strdup(argv[0]);
	else
		data->shell_name = ft_strdup("minishell");
	if (!data->shell_name)
	{
		perror("minishell: ft_strdup for shell_name");
		free_envp_copy(data->envp);
		close(data->stdin_fd);
		close(data->stdout_fd);
		close(data->stderr_fd);
		return (1);
	}
	data->envp = envp;
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/src/expand/ms_expand_var.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_expand_var.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/18 15:23:07 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/28 12:04:35 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * read after $
 * search env vars
 * if found read after =
 * rewrite string
 * 
 * 
 * expansions
 * $VAR
 * ${VAR}
*/

//TODO quotes "" and ''

/**
 * @brief Determines what needs expanding starting at '$' and its length.
 *
 * @param str The full input string.
 * @param d_pos Index where '$' was found (using 'd_pos' for brevity).
 * @param t_len Pointer to store the length of the target sequence
 * (e.g., "$?" is 2).
 * @return An allocated string containing the info
 * ("?", "VAR_NAME", "$") or NULL on error.
 * 
 * Cases
 * 1 basic checks and $ at end of string
 * 2 $?
 * 3 $$
 * 4 { }
 * 5 normal case - is valid var -> mode 0,
 * 6 else '$' followed by invalid char -> trat $ literally
 * 
 */
static char	*ms_get_expansion_info(const char *str, int dollar_pos, int *target_len)
{
	int		i;
	char	*info;

	i = dollar_pos + 1;
	*target_len = 1;
	info = NULL;
	if (!str || dollar_pos < 0 || str[dollar_pos] != '$' || str[i] == '\0')
		info = ft_strdup("$");
	else if (str[i] == '?')
	{
		*target_len = 2;
		info = ft_strdup("?");
	}
	else if (str[i] == '$')
	{
		*target_len = 2;
		info = ft_strdup("$$");
	}
	else if (str[i] == '{')
		info = ms_process_curly_expansion(str, i + 1, target_len, dollar_pos);
	else if (ms_valid_var(str[i], 0))
		info = ms_process_simple_var_expansion(str, i, target_len, dollar_pos);
	else
		info = ft_strdup("$");
	return (info);
}

/**
 * @brief Processes one potential expansion segment within the
 * main expansion loop.
 *        Appends literal part, gets info, gets value, appends value.
 *
 * @param str The original input string.
 * @param res_ptr Pointer to the result string pointer (modified).
 * @param cur_pos_ptr Pointer to the current position in 'str' (modified).
 * @param dol_pos The position of the current '$'.
 * @param status The last exit status for $?.
 * @return 0 on success, 1 on error.
 */
static int	ms_process_one_expansion(const char *str, char **res_ptr, \
									int *cur_pos_ptr, int dol_pos, int status)
{
	char	*info;
	char	*value;
	char	*literal;
	int		target_len;

	target_len = 0;
	literal = ft_substr(str, *cur_pos_ptr, dol_pos - *cur_pos_ptr);
	if (!literal || ms_append_and_free(res_ptr, literal))
	{
		free(literal);
		return (1);
	}
	free(literal);
	info = ms_get_expansion_info(str, dol_pos, &target_len);
	if (!info)
		return (1);
	value = ms_get_expansion_value(info, status);
	free(info);
	if (!value)
		return (1);
	if (ms_append_and_free(res_ptr, value))
		return (free(value), 1);
	free(value);
	*cur_pos_ptr = dol_pos + target_len;
	return (0);
}

/**
 * @brief Expands variables in a string using helper functions.
 *        !TODO QUOTES
 *
 * @param original_str The string to expand.
 * @param last_exit_status The exit status for $?.
 * @return A newly allocated expanded string, or NULL on error.
 */
static char	*ms_expand_str_help(const char *original_str, int last_exit_status)
{
	char	*result;
	char	*literal_part;
	int		current_pos;
	int		dollar_pos;

	result = ft_strdup("");
	if (!result)
		return (NULL);
	current_pos = 0;
	dollar_pos = -1;
	dollar_pos = ms_find_next_dollar(original_str, current_pos);
	while (dollar_pos != -1)
	{
		if (ms_process_one_expansion(original_str, &result, &current_pos,
				dollar_pos, last_exit_status) != 0)
			return (free(result), NULL);
		dollar_pos = ms_find_next_dollar(original_str, current_pos);
	}
	literal_part = ft_substr(original_str, current_pos,
			ft_strlen(original_str) - current_pos);
	if (!literal_part || ms_append_and_free(&result, literal_part))
		return (free(literal_part), free(result), NULL);
	return (free(literal_part), result);
}

/**
 * @brief Iterates through args array and expands variables in each argument
 *        using the helper-based expansion. Ignores quotes.
 *
 * @param args The argument array (from ft_split). Will be modified.
 * @param last_exit_status The value for $?.
 */
void	ms_expand_variables(char **args, int last_exit_status)
{
	int		i;
	char	*expanded_arg;

	if (!args)
		return ;
	i = 0;
	while (args[i])
	{
		if (ft_strchr(args[i], '$'))
		{
			expanded_arg = ms_expand_str_help(args[i], last_exit_status);
			if (!expanded_arg)
				ms_expand_error(args, i, 1);
			else
			{
				free(args[i]);
				args[i] = expanded_arg;
			}
		}
		i++;
	}
}


--------------------------------------------------
FILE: ./../minishell/src/expand/ms_expand_var_2.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_expand_var_2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/18 14:58:28 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 16:20:30 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief Helper for get_expansion_info to handle the $VAR case.
 *
 * @param str The full input string.
 * @param i Index position after the '$'.
 * @param t_len Pointer to update with the target length
 * (from '$' to end of name).
 * @param d_pos Index of the original '$'.
 * @return Allocated string with variable name, or NULL on malloc error.
 */
char	*ms_process_simple_var_expansion(const char *str, int i, \
		int *t_len, int d_pos)
{
	int		name_len;	
	char	*info_str;

	name_len = 0;
	while (ms_valid_var(str[i + name_len], 1))
		name_len++;
	*t_len = (i + name_len) - d_pos;
	info_str = ft_substr(str, i, name_len);
	return (info_str);
}

/**
 * @brief Helper for get_expansion_info to handle the ${VAR} case.
 *
 * @param str The full input string.
 * @param i Index position after the '{'.
 * @param t_len Pointer to update with the target length (from '$' to '}').
 * @param d_pos Index of the original '$'.
 * @return Allocated string with variable name,
 * or "$" if syntax error, or NULL on malloc error.
 * 
 * find }
 * extract name
 * no closing } -> treat $ literally 
 */
char	*ms_process_curly_expansion(const char *str, int i, \
		int *t_len, int d_pos)
{
	int		name_len;
	char	*info_str;

	name_len = 0;
	while (str[i + name_len] && str[i + name_len] != '}')
	{
		name_len++;
	}
	if (str[i + name_len] == '}')
	{
		*t_len = (i + name_len + 1) - d_pos;
		info_str = ft_substr(str, i, name_len);
	}
	else
	{
		*t_len = 1;
		info_str = ft_strdup("$");
	}
	return (info_str);
}

/**
 * @brief Gets the expanded value for the given info.
 *
 * @param info The info string ("?", "VAR_NAME", "$").
 * @param last_exit_status The exit status for $?.
 * @return An allocated string with the value, or NULL on memory error.
 * 
 * 1 Error
 * 2 $?
 * 3 $$
 * 4 literal $
 * 5 $VAR adn ${VAR}
 */
char	*ms_get_expansion_value(const char *info, int last_exit_status)
{
	char	*env_val;
	pid_t	pid;

	if (!info)
		return (NULL);
	if (ft_strcmp(info, "?") == 0)
		return (ft_itoa(last_exit_status));
	else if (ft_strcmp(info, "$$") == 0)
	{
		pid = getpid();
		return (ft_itoa((int)pid));
	}
	else if (ft_strcmp(info, "$") == 0)
		return (ft_strdup("$"));
	else
	{
		env_val = getenv(info);
		if (env_val)
			return (ft_strdup(env_val));
		else
			return (ft_strdup(""));
	}
}


--------------------------------------------------
FILE: ./../minishell/src/expand/ms_expand_var_utils.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_expand_var_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 16:54:06 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 16:00:29 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * mode 0 start - can't accept numbers
 * mode 1 after start - accept numbers
 */
int	ms_valid_var(char c, int mode)
{
	if (mode == 0)
	{
		if (isalpha(c) || c == '_')
		{
			return (true);
		}
	}
	else if (mode == 1)
	{
		if (isalnum(c) || c == '_')
		{
			return (true);
		}
	}
	return (false);
}

/**
 * print error
 * ft_putstr_fd(args[i] ? args[i] : "(null)", 2);
 */
int	ms_expand_error(char **args, int i, int mode)
{
	if (mode == 1)
	{
		ft_putstr_fd("minishell: expansion memory error for arg: ", 2);
		if (args[i])
			ft_putstr_fd(args[i], 2);
		else
			ft_putstr_fd("(null)", 2);
		ft_putstr_fd("\n", 2);
	}
	return (0);
}

/**
 * @brief Finds the index of the next '$' in 'str' at or after 'start_pos'.
 * @return Index of '$' or -1 if not found.
 */
int	ms_find_next_dollar(const char *str, int start_pos)
{
	const char	*dollar_ptr;

	if (!str || start_pos < 0 || (size_t)start_pos >= ft_strlen(str))
		return (-1);
	dollar_ptr = ft_strchr(str + start_pos, '$');
	if (dollar_ptr)
		return (dollar_ptr - str);
	return (-1);
}

/**
 * @brief Helper to append strings, freeing the old base string.
 * Assumes ft_strjoin allocates new memory.
 * @return 0 on success, 1 on error.
 */
int	ms_append_and_free(char **base_str_ptr, const char *to_append)
{
	char	*old;
	char	*new;

	if (!base_str_ptr || !*base_str_ptr || !to_append)
		return (1);
	old = *base_str_ptr;
	new = ft_strjoin(old, to_append);
	free(old);
	if (!new)
	{
		base_str_ptr = NULL;
		return (1);
	}
	*base_str_ptr = new;
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/src/prompt/ms_prompt.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_prompt.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/18 16:42:20 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/28 12:03:21 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief we could print the entire path or in this case just
 * the current directory name
 * 
 * get prompt
 * root directory
 * search for last slash
 * the function ends with safe fallback that shouldn't happen with absolute
 * paths
 */
static char	*ms_get_current_path(void)
{
	char		*full_path;
	const char	*dir_name_ptr;
	char		*last_slash;
	char		*result_name;

	full_path = getcwd(NULL, 0);
	if (!full_path)
		return (NULL);
	if (strcmp(full_path, "/") == 0)
		dir_name_ptr = "/";
	else
	{
		last_slash = ft_strrchr(full_path, '/');
		if (last_slash != NULL)
			dir_name_ptr = last_slash + 1;
		else
			dir_name_ptr = full_path;
	}
	result_name = ft_strdup(dir_name_ptr);
	free(full_path);
	if (!result_name)
		return (ft_putstr_fd("minishell: directory name allocation error\n", \
				2), NULL);
	return (result_name);
}

static int	ms_build_str_append(char **base_ptr, const char *to_append)
{
	char	*old_base;
	char	*new_base;

	if (!base_ptr || !to_append)
		return (1);
	if (!*base_ptr)
	{
		*base_ptr = ft_strdup(to_append);
		if (!*base_ptr)
		{
			ft_putstr_fd("minishell: prompt build allocation error\n", 2);
			return (1);
		}
		return (0);
	}
	old_base = *base_ptr;
	new_base = ft_strjoin(old_base, to_append);
	free(old_base);
	if (!new_base)
		return (*base_ptr = NULL, \
			ft_putstr_fd("minishell: prompt build allocation error\n", \
			2), 1);
	*base_ptr = new_base;
	return (0);
}

static char	*ms_build_fallback_prompt(const char *color)
{
	char	*prompt;

	prompt = ft_strdup(BLUE);
	if (prompt && ms_build_str_append(&prompt, "minishell") != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, color) != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, "> ") != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, RESET) != 0)
	{
	}
	if (!prompt)
		ft_putstr_fd("minishell: prompt allocation error (fallback)\n", 2);
	return (prompt);
}

/**
* @brief Builds the main dynamic part of the prompt string.
*        Format: BLUE "user@pwd" color "> " RESET
* @param user The username string.
* @param pwd The current directory string.
* @param color The color string (e.g., GREEN or RED) for '>'.
* @return Allocated string or NULL on failure.
*/
static char	*ms_build_dynamic_prompt(const char *user, const char *pwd, \
	const char *color)
{
	char	*prompt;

	prompt = ft_strdup(BLUE);
	if (prompt && ms_build_str_append(&prompt, user) != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, "@") != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, pwd) != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, color) != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, "> ") != 0)
	{
	}
	if (prompt && ms_build_str_append(&prompt, RESET) != 0)
	{
	}
	return (prompt);
}

/**
 * @brief Generates the prompt string dynamically.
 *
 * Format: BLUE "USERNAME@DIR" WHITE "> " RESET
 * Fallback: BLUE "minishell" WHITE "> " RESET
 * @return A newly allocated string containing the prompt, or NULL on error.
 *         The caller is responsible for freeing the returned string.
 * 
 * non zero staus represents error
 */
char	*ms_get_prompt(t_minishell *data)
{
	char		*user;
	char		*dir_name;
	char		*prompt;
	const char	*prompt_color;

	if (data->last_exit_status == 0)
		prompt_color = GREEN;
	else
		prompt_color = RED;
	user = getenv("USER");
	dir_name = ms_get_current_path();
	if (!user || !dir_name)
	{
		if (dir_name)
			free(dir_name);
		return (ms_build_fallback_prompt(prompt_color));
	}
	prompt = ms_build_dynamic_prompt(user, dir_name, prompt_color);
	free(dir_name);
	if (!prompt)
	{
		ft_putstr_fd("minishell: prompt build allocation error\n", 2);
		return (ms_build_fallback_prompt(prompt_color));
	}
	return (prompt);
}


--------------------------------------------------
FILE: ./../minishell/src/execution/ms_tree_exec.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_tree_exec.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/20 12:43:03 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/21 15:18:32 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/minishell.h"

int	ms_exec_heredoc(t_ast *node, t_minishell *data)
{
	t_ast	*cmd;
	t_ast	*limiter;
	int		pipefd[2];
	int		pid;
	char	*line;
	
	cmd = node->left;
	limiter = node->right;
	if (pipe(pipefd) == -1)
		return (perror("pipe"), 1);
	pid = fork();
	if (pid == 0)
	{
		close(pipefd[0]);
		while (1)
		{
			write(1, "> ", 2);
			line = get_next_line(STDIN_FILENO);
			if (!line)
				break ;
			if (ft_strncmp(line, limiter->args[0], ft_strlen(limiter->args[0])) == 0
				&& line[ft_strlen(limiter->args[0])] == '\n')
			{
				free(line);
				break ;
			}
			write(pipefd[1], line, ft_strlen(line));
			free(line);
		}
		close(pipefd[1]);
		exit(0);
	}
	close(pipefd[1]);
	waitpid(pid, NULL, 0);
	dup2(pipefd[0], STDIN_FILENO);
	close(pipefd[0]);
	return (ms_exec_tree(cmd, data));
}

int	ms_exec_redir_out(t_ast	*node, t_minishell *data)
{
	t_ast 	*cmd;
	t_ast 	*outfile;
	int		fd;

	cmd = node->left;
	outfile = node->right;
	if (node->type == TOKEN_REDIR_OUT)
		fd = open(outfile->args[0], O_CREAT | O_WRONLY | O_TRUNC, 0644);
	else
 		fd = open(outfile->args[0], O_CREAT | O_WRONLY | O_APPEND, 0644);
	if (fd < 0)
	{
		perror("open outfile");
		return (1);
	}
	dup2(fd, STDOUT_FILENO);
	close(fd);
	return (ms_exec_tree(cmd, data));
}

int	ms_exec_redir_in(t_ast *node, t_minishell *data)
{
	t_ast	*cmd;
	t_ast	*infile;
	int		fd;
	
	cmd = node->left;
	infile = node->right;
	fd = open(infile->args[0], O_RDONLY);
	if (fd < 0)
	{
		perror("open infile");
		return (1);
	}
	dup2(fd, STDIN_FILENO);
	close(fd);
	return (ms_exec_tree(cmd, data));
}

int	ms_exec_pipe(t_ast *node, t_minishell *data)
{
	int	pipefd[2];
	int	pid_1;
	int	pid_2;
	int status;
	
	pipe(pipefd);
	if ((pid_1 = fork()) == 0)
	{
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[1]);
		close(pipefd[0]);
		exit(ms_exec_tree(node->left, data));	
	}
	if ((pid_2 = fork()) == 0)
	{
		dup2(pipefd[0], STDIN_FILENO);
		close(pipefd[0]);
		close(pipefd[1]);
		exit(ms_exec_tree(node->right, data));
	}
	close(pipefd[0]);
	close(pipefd[1]);
	waitpid(pid_1, NULL, 0);
	waitpid(pid_2, &status, 0);
	return (WEXITSTATUS(status));	
}

int	ms_exec_cmd(t_ast *node, t_minishell *data)
{
	int		i;
	char 	full_path[1024];
	pid_t	pid;
	int		status;
	
	i = 0;
	if ((pid = fork()) == 0)
	{
		if (ft_strchr(node->args[0], '/'))
		{
			if (access(node->args[0], X_OK) == 0)
			{
				execve(node->args[0], node->args, data->envp);
				perror(node->args[0]);
				exit(127);
			}
			perror(node->args[0]);
			exit(127);
		}
		while (data->paths[i])
		{
			ft_strlcpy(full_path, data->paths[i], sizeof(full_path));
			ft_strlcat(full_path, "/", sizeof(full_path));
			ft_strlcat(full_path, node->args[0], sizeof(full_path));
			if (access(full_path, X_OK) == 0)
			{
				execve(full_path, node->args, data->envp);
				perror(full_path);
				exit (127);
			}
			i++;
		}
	}
	waitpid(pid, &status, 0);
	return (WEXITSTATUS(status));
}

int	ms_exec_tree(t_ast *node, t_minishell *data)
{
	if (!node)
		return 0;
	if (node->type == TOKEN_CMD)
		return (ms_exec_cmd(node, data));
	if (node->type == TOKEN_PIPE)
		return (ms_exec_pipe(node, data));
	if (node->type == TOKEN_REDIR_IN)
		return (ms_exec_redir_in(node, data));
	if (node->type == TOKEN_REDIR_OUT)
		return (ms_exec_redir_out(node, data));
	if (node->type == TOKEN_APPEND)
		return (ms_exec_redir_out(node, data));
	if (node->type == TOKEN_HEREDOC)
		return (ms_exec_heredoc(node, data));
	if (node->type == TOKEN_INFILE || node->type == TOKEN_OUTFILE
		|| node->type == TOKEN_EOF)
		return (0);
	return (1);
}

--------------------------------------------------
FILE: ./../minishell/src/main.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/06 17:22:18 by goteixei          #+#    #+#             */
/*   Updated: 2025/05/26 15:56:27 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/minishell.h"

// Definition of the global variable
//extern unsigned char	g_signal;
volatile sig_atomic_t g_signal;

/**
 * @brief The main interactive loop of the minishell.
 *
 * Reads input using readline, adds it to history, checks for "exit",
 * and prepares for parsing/execution (currently just prints input).
 * Handles EOF (Ctrl+D).
 * 
 * 1. Read input with prompt
 * 2. Handle EOF (CTRL+D) - input_line == NULL
 * 3. Handle empty input (Enter)
 * 4. Add non-empty input to history
 * 5. Check for exit command
 * 6. Placeholder for parsing
 * 7. Free input line
 * 
 * SIGINT = 130
 */
static void	ms_core_loop(t_minishell *data)
{
	char	*input_line;
	//char	**args;
	char	*prompt_str;
	int		saved_errno;

	g_signal = 0;
	while (1)
	{
		if (g_signal == SIGINT)
		{
			data->last_exit_status = 130;
			g_signal = 0;
		}
		prompt_str = ms_get_prompt(data);
		if (!prompt_str)
		{
			ft_putstr_fd("Minishell: Critical error generating prompt. \
			Exiting.\n", 2);
			break ;
		}
		input_line = readline(prompt_str);
		free(prompt_str);

		saved_errno = errno;
		ft_printf(YELLOW "DEBUG SIGINT detected! errno=%d (%s)\n" \
		RESET, saved_errno, strerror(saved_errno));

		if (g_signal == SIGINT)
		{
			data->last_exit_status = 130;
			g_signal = 0;
			if (input_line)
				free(input_line);
			rl_done = 0;
			continue ;
		}
		if (input_line == NULL)
		{
			ft_putstr_fd("exit\n", STDOUT_FILENO);
			break ;
		}
		if (input_line[0] == '\0')
		{
			free(input_line);
			continue ;
		}
		add_history(input_line);

	

		// --- Syntax check ---
		// ft_printf(YELLOW "DEBUG Received: <%s>\n" RESET, input_line);
		//args = ms_parse_input_placeholder(input_line);
		if (ms_syntax_check(input_line))
		{
			data->last_exit_status = 2; //or 258?
			free(input_line);
			continue ;
		}
	
		// --- PARSING AND EXECUTION ---
		
		ms_main_parsing(input_line, data);



		// if (!args)
		// {
		// 	free(input_line);
		// 	g_signal = 1;
		// 	continue ;
		// }
		// ms_expand_variables(args, data->last_exit_status);
		// ms_debug_print_args(args);
		// g_signal = ms_execute_command_placeholder(args, data);
		// ms_debug_print_gsig();
		// ms_free_split_args(args);
		// free(input_line);
		// input_line = NULL;


		free(input_line);
	}
	rl_clear_history();
	// free shell data
}

/**
 * shell _data is the main struct created on the stack
 */
int	main(int argc, char **argv, char **envp)
{
	t_minishell	shell_data;

	(void) argc;
	(void) argv;
	if (init_shell_data(&shell_data, argv, envp) != 0)
		return (EXIT_FAILURE);
	//ms_signal_handlers_init();
	ms_signal_handlers_set_interactive();
	printf(GREEN "DEBUG Minishell Start!\n---\n" RESET "\n");
	ms_core_loop(&shell_data);
	printf(RED "\n---\nDEBUG Exiting Minishell. Final status: %d" RESET "\n", \
		g_signal);
	//return (g_signal);
	return(shell_data.last_exit_status);
}


--------------------------------------------------
FILE: ./../minishell/src/parsing/ms_main_parsing.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_main_parsing.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 15:03:26 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/22 15:44:33 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/minishell.h"

void	ms_main_parsing(char *input, t_minishell *data)
{
	t_token	*tokens;
	t_ast	*ast_tree;
	
	tokens = ms_tokenization(input);
	ms_print_tokens(tokens);
	ast_tree = ms_parse_tokens(&tokens);
	print_ast(ast_tree, 0);
	ms_exec_tree(ast_tree, data);
}

void print_indent(int level)
{
	for (int i = 0; i < level; i++)
		printf("  ");
}

const char *get_token_type_name(t_token_type type)
{
	switch (type)
	{
		case TOKEN_INFILE: return "INFILE";
		case TOKEN_OUTFILE: return "OUTFILE";
		case TOKEN_CMD: return "CMD";
		case TOKEN_PIPE: return "PIPE";
		case TOKEN_REDIR_IN: return "REDIR_IN";
		case TOKEN_REDIR_OUT: return "REDIR_OUT";
		case TOKEN_APPEND: return "APPEND";
		case TOKEN_HEREDOC: return "HEREDOC";
		case TOKEN_EOF: return "EOF";
		default: return "UNKNOWN";
	}
}


void print_ast(t_ast *node, int level)
{
	if (!node)
		return;

	print_indent(level);
	printf("Node Type: %s\n", get_token_type_name(node->type));

	if (node->args)
	{
		for (int i = 0; node->args[i]; i++)
		{
			print_indent(level + 1);
			printf("Arg[%d]: %s\n", i, node->args[i]);
		}
	}

	if (node->left)
	{
		print_indent(level);
		printf("Left:\n");
		print_ast(node->left, level + 1);
	}

	if (node->right)
	{
		print_indent(level);
		printf("Right:\n");
		print_ast(node->right, level + 1);
	}
}


--------------------------------------------------
FILE: ./../minishell/src/parsing/ms_parser_placeholder.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_parser_placeholder.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/07 18:04:12 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/28 11:28:22 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

extern int g_last_exit_status;

/**
 * @brief Frees the memory allocated for a NULL-terminated string array
 *        (like one returned by ft_split).
 * @param args The string array to free.
 */
void	ms_free_split_args(char **args)
{
	int	i;

	if (!args)
		return;
	i = 0;
	while (args[i])
	{
		free(args[i]);
		i++;
	}
	free(args);
}

/**
 * @brief VERY basic placeholder parser using ft_split.
 * Splits the input line by spaces. Does NOT handle quotes, etc.
 * @param input_line The raw input line from readline.
 * @return A NULL-terminated array of strings (arguments), or NULL on failure.
 */
char	**ms_parse_input_placeholder(const char *input_line)
{
	char	**args;

	// NOTE: This split is NOT robust (doesn't handle quotes, etc.)
	// Replace with real tokenizer/parser later.
	args = ft_split(input_line, ' '); // Assumes ft_split exists
	if (!args)
	{
		perror("minishell: placeholder parser (ft_split) failed");
		// Don't free input_line here, the caller (main) still owns it
		return (NULL); // Signal failure
	}
	return (args);
}

int	ms_execute_command_placeholder(char **args, t_minishell *data)
{
	if (args == NULL || args[0] == NULL)
		return (0);
	if (strcmp(args[0], "cd") == 0)
		return (ms_execute_cd(args));
	if (strcmp(args[0], "echo") == 0)
		return (ms_execute_echo(args));
	if (strcmp(args[0], "env") == 0)
		return (ms_execute_env(args, data->envp));
	if (strcmp(args[0], "exit") == 0)
		return (ms_execute_exit(args));
	if (strcmp(args[0], "export") == 0)
		return ms_execute_export(args, data);
	else if (strcmp(args[0], "pwd") == 0)
		return (ms_execute_pwd(args));
	else if (strcmp(args[0], "unset") == 0)
		return (ms_execute_unset((args), data));
	else
		return (ms_execute_external_command(args, data->envp));
}


--------------------------------------------------
FILE: ./../minishell/src/parsing/ms_parsing.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_parsing.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/19 20:15:36 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/19 15:41:03 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_ast	*ms_parse_command(t_token **token)
{
	t_ast	*command_node;
	char	**args;

	args = ft_split((*token)->value, ' ');
	if (!args)
		return NULL;
	command_node = ms_new_ast_node(TOKEN_CMD);
	command_node->args = args;
	free(*token);
	return(command_node);
}

t_ast	*ms_create_file_node(t_token *token)
{
	t_ast	*node;

	node = malloc(sizeof(t_ast));
	if (!node)
		return (NULL);
	node->type = token->type;
	node->args = malloc(sizeof(char *) * 2);
	if (!node->args)
	{
		free(node);
		return (NULL);
	}
	node->args[0] = token->value;
	node->args[1] = NULL;
	node->left = NULL;
	node->right = NULL;
	free(token);
	return (node);
}

t_ast	*ms_parse_redirection(t_token	**token_list)
{
	t_token	*temp;
	t_token	*next_token;
	t_ast	*redirect_node;

	if (!*token_list) 
		return (NULL);
	temp = *token_list;
	if ((*token_list)->type >= TOKEN_REDIR_IN
		&& (*token_list)->type <= TOKEN_HEREDOC)
			return (ms_create_and_link_redir(token_list, temp));
	while (*token_list && (*token_list)->next)
	{
		next_token = (*token_list)->next;
		if (next_token->type >= TOKEN_REDIR_IN
			&& next_token->type <= TOKEN_HEREDOC)
			{
				redirect_node = ms_new_ast_node(next_token->type);
				(*token_list)->next = next_token->next->next;
				redirect_node->left = ms_parse_redirection(&temp);
				redirect_node->right = ms_create_file_node(next_token->next);
				return (free(next_token->value), free(next_token), redirect_node);
			}
		*token_list = next_token;
	}
	return (ms_parse_command(&temp));
}

t_ast	*ms_parse_pipes(t_token **token_list)
{
	t_token	*temp;
	t_token	*next_token;
	t_ast	*pipe_node;

	temp = *token_list;
	while (*token_list && (*token_list)->next)
	{
		next_token = (*token_list)->next;
		if (next_token->type == TOKEN_PIPE)
		{
			pipe_node = ms_new_ast_node(next_token->type);
			(*token_list)->next = NULL;
			pipe_node->left = ms_parse_redirection(&temp);
			pipe_node->right = ms_parse_pipes(&(next_token->next));
			free(next_token->value);
			free(next_token);
			return (pipe_node);
			}
		*token_list = next_token;
	}
	return (ms_parse_redirection(&temp));
}

t_ast 	*ms_parse_tokens(t_token	**token_list)
{ 
	if (!token_list)
		return (NULL);
	return (ms_parse_pipes(token_list));
}


--------------------------------------------------
FILE: ./../minishell/src/parsing/ms_parsing_utils.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_parsing_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 13:12:32 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/22 15:56:27 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_ast	*ms_new_ast_node(t_token_type type)
{
	t_ast	*node;

	node = malloc(sizeof(t_ast));
	if (!node)
		return (NULL);
	node->type = type;
	node->args = NULL;
	node->left = NULL;
	node->right = NULL;
	return (node);
}

t_ast *ms_create_and_link_redir(t_token **token_list, t_token *temp)
{
	t_ast *redirect_node = ms_new_ast_node(temp->type);

	t_token *file_token = temp->next;
	if (!file_token)
	{
		free(temp->value);
		free(temp);
		free(redirect_node);
		return (NULL);
	}
	*token_list = file_token->next;
	redirect_node->right = ms_create_file_node(file_token);
	if (*token_list)
	{
		if ((*token_list)->type >= TOKEN_REDIR_IN && (*token_list)->type <= TOKEN_HEREDOC)
			redirect_node->left = ms_parse_redirection(token_list);
		else
			redirect_node->left = ms_parse_command(token_list);
	}
	else
		redirect_node->left = NULL;
	free(temp->value);
	free(temp);
	return redirect_node;
}


--------------------------------------------------
FILE: ./../minishell/src/syntax_check/ms_debug_input.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_debug_input.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 11:42:08 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/26 16:34:42 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief Prints the command and its arguments individually for debugging.
 *
 * @param context A string describing the context (e.g., "Parsed Arguments").
 * @param args The NULL-terminated array of strings (command and args).
 */
void	ms_debug_print_args(char **args)
{
	int	i;

	if (args == NULL)
	{
		ft_printf(MAGENTA "DEBUG Args array is NULL.\n" RESET);
		return ;
	}
	if (args[0] == NULL)
	{
		ft_printf(MAGENTA "DEBUG No command found (args[0] is NULL).\n" RESET);
		return ;
	}
	ft_printf(MAGENTA "DEBUG Command: [%s]\n" RESET, args[0]);
	i = 1;
	while (args[i] != NULL)
	{
		ft_printf(MAGENTA "DEBUG Opt/Arg %d: [%s]\n" RESET, i, args[i]);
		i++;
	}
	if (i == 1)
		ft_printf(MAGENTA "DEBUG (No options or arguments)\n" RESET);
}


--------------------------------------------------
FILE: ./../minishell/src/syntax_check/ms_syntax_check.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_syntax_check.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/10 17:51:13 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/08 18:10:02 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

bool ms_syntax_check(char *input_line)
{
	bool	error;
	char	*input;

	input = ms_remove_whitespaces(input_line);
	if((error = ms_unclosed_quotes(input)) == true)
	{
		ft_putstr_fd("Syntax error: unclosed quotes\n", 2);
		return (error);
	}
	if((error = ms_not_required(input_line)) == true)
	{
		ft_putstr_fd("error: special characters which are not required by the subject\n", 2);
		return (error);		
	}
	if((error = ms_pipes_placement(input)) == true)
	{
		ft_putstr_fd("Syntax error: misplaced pipes\n", 2);
		return (error);
	}
	if((error = ms_rediractions_placement(input)) == true)
	{
		ft_putstr_fd("Syntax error: misplaced rediractions\n", 2);
		return(error);
	}
	return (false);
}

bool ms_unclosed_quotes(char *input)
{
	int quote_type;
	int	i;
	
	i = 0;
	quote_type = 0;
	while(input[i])
	{
		if ((input[i] == '\"') || (input[i] == '\''))
		{
			if (quote_type == 0)
				quote_type = input[i];
			else if (quote_type == input[i])
				quote_type = 0;
		}
		i++;
	}
	if (quote_type == 0)
		return (false);
	else
		return (true);
}

bool ms_pipes_placement(char *input)
{
	int i;
	int	pipe;

	pipe = 0;
	i = ft_strlen(input);
	if ((input[0] == '|') || (input[i - 1] == '|'))
		return (true);
	i = 0;
	while (input[i])
	{
		ms_skip_whitespaces(&i, input);
		ms_skip_inside_quotes(&i, input);
		if (input[i] == '|')
			pipe++;
		else
			pipe = 0;
		if (pipe == 2)
			return (true);
		i++;
	}
	return (false);
}

bool ms_rediractions_placement(char *input)
{
	int	x;
	int i;

	i = 0;
	x = ft_strlen(input) - 1;
	if (input[x] == '<' || input[x] == '>')
		return (true);
	x = 0;
	i = 0;
	while (input[i])
	{
		ms_skip_whitespaces(&i, input);
		ms_skip_inside_quotes(&i, input);
		if (input[i] == '>')
		{
			i++;
			if (input[i] == '>')
				i++;
			ms_skip_whitespaces(&i, input);
			if ((input[i] == '>') || (input[i] == '<'))
				return (true);
		}
		if (input[i] == '<')
		{
			i++;
			if (input[i] == '<')
				i++;
			ms_skip_whitespaces(&i, input);
			if ((input[i] == '>') || (input[i] == '<'))
				return (true);
		}
		i++;
	}
	return (false);
}

bool ms_not_required (char *input)
{
	int quote_type;
	int	i;

	i = 0;
	quote_type = 0;
	while (input[i])
	{
		if (input[i] == '\'' || input[i] == '\"')
		{
			if (quote_type == 0)
				quote_type = input[i];
			else if (quote_type == input[i])
				quote_type = 0;
		}
		if ((input[i] == '\\' || input[i] == ';') && quote_type == 0)
			return (true);\
		else if ((input[i] == '&' || (input[i] == '|' && input[i + 1] == '|')) && quote_type == 0)
			return (true);
		i++;
	}
	return (false);
}


--------------------------------------------------
FILE: ./../minishell/src/syntax_check/ms_syntax_utils.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_syntax_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/16 16:43:34 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/16 16:43:36 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

char	*ms_remove_whitespaces(char	 *input_line)
{
	int		start;
	int		finish;
	char	*input;
	int		i;

	i = 0;
	start = 0;
	finish = ft_strlen(input_line) - 1;
	while ((input_line[start] == 32) || (input_line[start] >= 7 && input_line[start] <= 13))
		start++;
	while ((input_line[finish] == 32) || (input_line[finish] >= 7 && input_line[finish] <= 13))
		finish--;
	input = malloc((finish - start) + 1);
	while (start <= finish)
	{
		input[i] = input_line[start];
		start++;
		i++;
	}
	input[i] = '\0';
	return (input);
}

void	ms_skip_inside_quotes(int *i, char *input)
{
	if (input[*i] == 34)
	{
		(*i)++;
		while (input[*i] && input[*i] != 34 && input[*i + 1] != 34)
			(*i)++;
	}
	if (input[*i] == 39)
	{
		(*i)++;
		while (input[*i] && input[*i] != 39 && input[*i + 1] != 39)
			(*i)++;
	}
	(*i)++;
}

void	ms_skip_whitespaces(int *i, char *input)
{
	while (input[*i] == 32 || (input[*i] >= 7 && input[*i] <= 13))
		(*i)++;
}


--------------------------------------------------
FILE: ./../minishell/src/tokenization/ms_list_utils.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_list_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/11 14:28:17 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/19 15:08:51 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/minishell.h"

/**
 * @brief Returns the last node in a linked list of tokens.
 *
 * This function iterates through the `t_tokens` linked list until it reaches
 * the final node (i.e., the node where `next` is NULL). If the list is empty,
 * it returns NULL.
 * 
 * @param list The head of the token list.
 * 
 * @return A pointer to the last node in the list, or NULL if the list is empty.
 */
t_token *ms_last_node(t_token *list)
{
	if (!list)
		return (NULL);
	while (list->next)
		 list = list->next;
	return (list);
}
/**
 * @brief Creates a new token node and appends it to the end of the token list.
 *
 * This function allocates memory for a new `t_tokens` node, duplicates the given
 * input string as the token's content, assigns its type, and appends it to the
 * end of the existing linked list. If the list is initially NULL, it creates and
 * returns a new list with a single node.
 * 
 * @param list The current token list to append to (can be NULL to start a new list).
 * @param input The string value of the token (e.g. command, operator).
 * @param type The type of the token (e.g. WORD, PIPE, IN, OUT).
 * 
 * @return The updated token list including the newly added node.
 */
t_token *ms_append_node(t_token *list, char  *input, t_token_type type)
{
	t_token	*last_node;
	t_token	*new_node;
	
	new_node = malloc(sizeof(t_token));
	if (!new_node)
		return (NULL);
	new_node->value = ft_strdup(input);
	new_node->type = type;
	new_node->expand = NULL;
	new_node->state = GENERAL;
	new_node->expand_index = NULL;
	new_node->previous = NULL;
	new_node->next = NULL;
	if  (list == NULL)
		list = new_node;
	else
	{
		last_node = ms_last_node(list);
		last_node->next = new_node;
		new_node->previous = last_node;
	}
	return (list);
}

void ms_print_tokens(t_token *list)
{
	char	*type[] = {"INFILE", "OUTFILE", "CMD", "PIPE", "IN", "OUT", "APPEND", "HEREDOC", "EOF"};
	char	*state[] = {"GENERAL", "DOUBLE_QUOTES", "SIMPLE_QUOTES"};
	int i;

	i = 0;
	while (list)
	{
		ft_printf(GREEN"---------------------------------\n");
		ft_printf(GREEN"value: %s\n", list->value);
		ft_printf(GREEN"Type:  %s\n", type[list->type]);
		ft_printf(GREEN"State: %s\n", state[list->state]);
		printf("expansion: %s\n", list->expand ? "true" : "false");
		if (list->expand)
		{
			i = 0;
			while (list->expand_index[i] != -1)
			{
				ft_printf("index: %d\n", list->expand_index[i]);
				i++;
			}
		}
		ft_printf("\n");
		list = list->next;
	}
}


--------------------------------------------------
FILE: ./../minishell/src/tokenization/ms_quotes.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_quotes.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 13:02:33 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/15 12:41:18 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	ms_normal_index(t_token *list)
{
	int		i;
	int		k;
	int		*index;
	int		count;
	
	i = 0;
	k = 0;
	count = ms_count_normal(list->value);
	if (count == 0)
		return ;
	index = malloc((count + 1) * sizeof(int));
	if (!count)
		exit(EXIT_FAILURE);
	while (list->value[i])
	{
		if (list->value[i] == '$')
		{
			index[k] = i;
			k++;
			list->expand = true;
		}
		i++;
	}
	index[k] = -1;
	list->expand_index = index;
}

int	*ms_put_index(t_token *list, int *index, int i, int k)
{
	while (list->value[i])
	{
		if (list->value[i] == '\'')
		{
			i++;
			while (list->value[i] != '\''  && list->value[i])
				i++;
		}
		if (list->value[i] == '\"')
		{
			i++;
			while (list->value[i] != '\"' && list->value[i] && ms_another_double(i, list->value))
			{
				if (list->value[i] == '$')
				{
					list->expand = true;
					index[k] = i;
					k++;
				}
				i++;
			}
		}
		i++;
	}
	return (index);
}

void ms_quotes_index(t_token *list)
{
	int	*index;
	int	count;

	count = ms_quotes_count(list);
	if (count == 0)
		return ;
	index = malloc((count + 1) * sizeof(int));
	if (!index)
		exit(EXIT_FAILURE);
	index = ms_put_index(list, index, 0, 0);
	index[count] = -1;
	list->expand_index = index;
}

t_token	*ms_expansion_index(t_token *list)
{
	t_token	*temp;

	temp = list;
	while (temp)
	{
		if (temp->type >= 3 && temp->type <= 7)
		{
			temp = temp->next;
			continue;
		} 
		if (temp->state == DOUBLE_QUOTES || temp->state == SIMPLE_QUOTES)
			ms_quotes_index(temp);
		else
			ms_normal_index(temp);
		temp = temp->next;
	}
	return (list);
}


--------------------------------------------------
FILE: ./../minishell/src/tokenization/ms_quotes_off.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_quotes_off.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 14:58:29 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/15 12:17:35 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

int	ms_new_size(char *value)
{
	int	i;
	int	len;
	int	quote_type;

	quote_type = value[0];
	i = 1;
	len = 0;
	while (value[i])
	{
		if (value[i] == quote_type && value[i + 1])
		{
			i++;
			quote_type = value[i];
			i++;
			continue;
		}
		else if (value[i] == quote_type && !value[i + 1])
			break ;
		len++;
		i++;
	}
	return (len);
}

char	*ms_put_new(char *value, char *new_value)
{
	int	i;
	int	k;
	int	quote_type;

	quote_type = value[0];
	i = 1;
	k = 0;
	while (value[i])
	{
		if(value[i] == quote_type && value[i + 1])
		{
			i++;
			quote_type = value[i];
			i++;
			continue;
		}
		else if (value[i] == quote_type && !value[i + 1])
			break ;
		new_value[k] = value[i];
		k++;
		i++;
	}
	new_value[k] = '\0';
	return (new_value);
}

t_token *ms_quotes_off(t_token *list)
{
	t_token *temp;
	int		new_size;
	char	*new_value;

	temp = list;
	while (temp)
	{
		if(!(temp->state == DOUBLE_QUOTES || temp->state == SIMPLE_QUOTES))
		{
			temp = temp->next;
			continue;
		}
		new_size = ms_new_size(temp->value);
		new_value = malloc(new_size + 1);
		if (!new_value)
			exit(EXIT_FAILURE);
		new_value = ms_put_new(temp->value, new_value);
		free(temp->value);
		temp->value = new_value;
		temp = temp->next;
	}
	return (list);	
}


--------------------------------------------------
FILE: ./../minishell/src/tokenization/ms_quotes_utils.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_quotes_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 13:03:38 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/14 13:03:57 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

bool	ms_another_double(int i, char *value)
{
	while (value[i])
	{
		if (value[i] == '\"')
			return (true);
		i++;
	}
	return (false);
}

int	ms_count_normal(char *string)
{
	int	i;
	int count;

	count = 0;
	i = 0;
	while (string[i])
	{
		if  (string[i] == '$')
			count++;
		i++;
	}
	return (count);
}

int ms_quotes_count(t_token	*list)
{
	int	i;
	int	count;

	count = 0;
	i = 0;
	while (list->value[i])
	{
		if (list->value[i] == '\'')
		{
			i++;
			while (list->value[i] != '\''  && list->value[i])
				i++;
		}
		if (list->value[i] == '\"')
		{
			i++;
			while (list->value[i] != '\"' && list->value[i] && ms_another_double(i, list->value))
			{
				if (list->value[i] == '$')
					count++;
				i++;
			}
		}
		i++;
	}
	return (count);
}


--------------------------------------------------
FILE: ./../minishell/src/tokenization/ms_tokenization.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_tokenization.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/16 14:57:22 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/19 15:06:33 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_token	*ms_extract_cmd(char *input, int *i, t_token *list)
{
	char	*word;
	int 	k;

	
	word = malloc(ms_len_cmd(input, *i) + 1);
	if (!word)
		return NULL;
	k = 0;
	while (input[*i])
	{
		if(input[*i] == '|' ||  (input[*i] == '<' || input[*i] == '>'))
			break;
		else if ((input[*i] == '\'') || (input[*i] == '\"'))
			break;
		word[k] = input[*i];
		(*i)++;
		k++;
	}
	word[k] = '\0';
	list = ms_append_node(list, word, TOKEN_CMD);
	free(word);
	return (list);
}

t_token	*ms_extract_file(char *input, int *i, t_token *list)
{
	char	*word;
	int 	k;

	
	word = malloc(ms_len_file(input, *i) + 1);
	if (!word)
		return NULL;
	k = 0;
	while (input[*i])
	{
		if(input[*i] == 32 || (input[*i] >= 7 && input[*i] <= 13))
			break;
		if(input[*i] == '|' ||  (input[*i] == '<' || input[*i] == '>'))
			break;
		word[k] = input[*i];
		(*i)++;
		k++;
	}
	word[k] = '\0';
	if (ms_is_infile(list))
		list = ms_append_node(list, word, TOKEN_INFILE);
	else
		list = ms_append_node(list, word, TOKEN_OUTFILE);		
	free(word);
	return (list);
}

t_token *ms_extract_quotes(char *input, int *i, t_token *list)
{
	char	quote_type;
	char	*quote;
	int		k;
	int		len;
	
	quote_type = input[*i];
	len = ms_quote_len(input, *i);
	quote = malloc(len + 2);
	if (!quote)
		return NULL;
	k = 0;
	while (input[*i] && k <= len)
		quote[k++] = input[(*i)++];
	quote[k] = '\0';
	if(ms_is_file(list))
	{
		if (ms_is_infile(list))
			list = ms_append_node(list, quote, TOKEN_INFILE);
		else
			list = ms_append_node(list, quote, TOKEN_OUTFILE);
	}
	else
		list = ms_append_node(list, quote, TOKEN_CMD);
	free(quote);
	return (list);	
}

t_token *ms_start_tokenization(char *input, t_token *list)
{
	int			i;
	
	i = 0;
	input = ms_remove_whitespaces(input);
	while (input[i])
	{
		ms_skip_whitespaces(&i, input);
		if((input[i] == '|') || (input[i] == '<' || input[i] == '>'))
			list = ms_extract_operator(input, &i, list);
		else if((input[i] == '\'') || (input[i] == '\"'))
			list = ms_extract_quotes(input, &i, list);
		else if(ms_is_file(list))
			list =  ms_extract_file(input, &i, list);
		else
			list = ms_extract_cmd(input, &i, list);
	}
	return (list);
}

t_token	*ms_tokenization(char *input)
{
	t_token		*list;

	list = NULL;
	list = ms_start_tokenization(input, list);
	list = ms_assign_state(list);
	list = ms_check_eof(list);
	list = ms_expansion_index(list);
	//list = expansao
	list = ms_quotes_off(list);
	return (list);
}

--------------------------------------------------
FILE: ./../minishell/src/tokenization/ms_tokenization_utils.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_tokenization_utils.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 16:36:05 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/16 16:58:35 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

/**
 * @brief Calculates the length of the next word token in the input string.
 *
 * This function scans the input from the given index until it hits a shell
 * metacharacter (`|`, `<`, `>`) or a whitespace character (space, tab, newline, etc.).
 * The length of the continuous sequence of regular characters is returned.
 * 
 * @param input The full input string being scanned.
 * @param i The starting index in the input string.
 * 
 * @return The length of the word token found at the given index.
 */

int	ms_len_file(char *input, int i)
{
	int len;

	len = 0;
	while (input[i])
	{
		if(input[i] == 32 || (input[i] >= 7 && input[i] <= 13))
			break;
		if(input[i] == '|' ||  (input[i] == '<' || input[i] == '>'))
			break;
		i++;
		len++;
	}
	return (len);
}

int	ms_len_cmd(char *input, int i)
{
	int len;

	len = 0;
	while (input[i])
	{
		if(input[i] == '|' ||  (input[i] == '<' || input[i] == '>'))
			break;
		i++;
		len++;
	}
	return (len);
}

int ms_quote_len(char *input, int i)
{
	int		len;
	char	quote_type;
	
	quote_type = input[i];
	len = 1;
	i++;
	while (input[i])
	{
		if(input[i] == quote_type)
		{
			if(input[i + 1] == '\'' || input[i + 1] == '\"')
			{
				i++;
				len++;
				quote_type = input[i];
			}
			else
				break;  	
		}
		len++;
		i++;
	}
	return (len);
}

t_token *ms_extract_operator(char *input, int *i, t_token *list)
{
	if (input[*i] == '|')
		list = ms_append_node(list, "|", TOKEN_PIPE);
	else if (input[*i] == '<' && input[*i + 1] == '<')
	{
		list = ms_append_node(list, "<<", TOKEN_HEREDOC);
		*i += 2;
		return (list);
	}
	else if (input[*i] == '>' && input[*i + 1] == '>')
	{
		list = ms_append_node(list, ">>", TOKEN_APPEND);
		*i += 2;
		return (list);
	}
	else if (input[*i] == '<')
		list = ms_append_node(list, "<", TOKEN_REDIR_IN);
	else if (input[*i] == '>')
		list = ms_append_node(list, ">", TOKEN_REDIR_OUT);
	(*i)++;
	return list;
}


--------------------------------------------------
FILE: ./../minishell/src/tokenization/ms_tokenization_utils2.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_toknization_utils2.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/16 16:56:27 by jpedro-f          #+#    #+#             */
/*   Updated: 2025/05/16 16:57:57 by jpedro-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

bool	ms_is_file(t_token	*list)
{
	t_token	*last_node;
	
	last_node = ms_last_node(list);
	if (last_node == NULL)
		return (false);
	if(last_node->type == TOKEN_REDIR_IN || 
		last_node->type == TOKEN_REDIR_OUT || 
			last_node->type == TOKEN_APPEND)
		return (true);
	else
		return (false);
}

bool	ms_is_infile(t_token *list)
{
	t_token	*last_node;
	
	last_node = ms_last_node(list);
	if(last_node->type == TOKEN_REDIR_IN)
		return (true);
	else
		return (false);
}

t_token	*ms_assign_state(t_token *list)
{
	t_token	*temp;

	temp = list;
	while (temp)
	{
		if (temp->value[0] == '\'')
			temp->state = SIMPLE_QUOTES;
		else if (temp->value[0] == '\"')
			temp->state = DOUBLE_QUOTES;
		temp = temp->next;	
	}
	return (list);
}

t_token *ms_check_eof(t_token *list)
{
	t_token	*temp;

	temp = list;
	while (temp)
	{
		if (temp->type == TOKEN_HEREDOC && temp->next)
			temp->next->type = TOKEN_EOF;
		temp = temp->next;
	}
	return (list);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/Makefile
--------------------------------------------------
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/10/31 22:48:46 by goteixei          #+#    #+#              #
#    Updated: 2025/04/18 16:26:51 by goteixei         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# --- Program Name ---
NAME = libft.a

# --- Directories ---
SRC_DIR = .
FT_PRINTF_DIR = ft_printf
GNL_DIR = get_next_line

# --- Compiler and Flags ---
CC				= cc
RM				= rm -f
CFLAGS			= -Wall -Wextra -Werror -g
CFLAGS			+= -I.

# --- Directories ---
SRC_DIR = .
FT_PRINTF_DIR = ft_printf
GNL_DIR = get_next_line

SRCS	= ft_isalpha.c\
		ft_isdigit.c\
		ft_isascii.c\
		ft_isalnum.c\
		ft_isprint.c\
		ft_strlen.c\
		ft_memset.c\
		ft_bzero.c\
		ft_memcpy.c\
		ft_memmove.c\
		ft_strlcpy.c\
		ft_strlcat.c\
		ft_toupper.c\
		ft_tolower.c\
		ft_strchr.c\
		ft_strrchr.c\
		ft_strncmp.c\
		ft_memchr.c\
		ft_memcmp.c\
		ft_strnstr.c\
		ft_atoi.c\
		ft_calloc.c\
		ft_strdup.c\
		ft_substr.c\
		ft_strjoin.c\
		ft_strtrim.c\
		ft_split.c\
		ft_itoa.c\
		ft_strmapi.c\
		ft_striteri.c\
		ft_putchar_fd.c\
		ft_putstr_fd.c\
		ft_putendl_fd.c\
		ft_putnbr_fd.c\
		ft_lstnew.c\
		ft_lstadd_front.c\
		ft_lstsize.c\
		ft_lstlast.c\
		ft_lstadd_back.c\
		ft_lstdelone.c\
		ft_lstclear.c\
		ft_lstiter.c\
		ft_lstmap.c\
		ft_putendl.c\
		ft_putstr.c\
		ft_putchar.c\
		ft_atol.c\
		ft_error.c\
		ft_atoi_base.c\
		ft_abs.c\
		ft_max.c\
		ft_min.c\
		ft_strcmp.c

# Source files for ft_printf
FT_PRINTF_SRCS = $(FT_PRINTF_DIR)/ft_printf.c \
				 $(FT_PRINTF_DIR)/ft_print_char.c \
				 $(FT_PRINTF_DIR)/ft_print_str.c \
				 $(FT_PRINTF_DIR)/ft_print_ptr.c \
				 $(FT_PRINTF_DIR)/ft_print_unsigned.c \
				 $(FT_PRINTF_DIR)/ft_print_hex.c \
				 $(FT_PRINTF_DIR)/ft_print_int.c \
				 $(FT_PRINTF_DIR)/ft_print_percent.c

# Source files for get_next_line
GNL_SRCS		= $(GNL_DIR)/get_next_line.c \
				$(GNL_DIR)/get_next_line_utils.c

# --- Object Files ---
OBJS = $(SRCS:.c=.o)
FT_PRINTF_OBJS = $(FT_PRINTF_SRCS:.c=.o)
GNL_OBJS = $(GNL_SRCS:.c=.o)

ALL_OBJS = $(OBJS) $(FT_PRINTF_OBJS) $(GNL_OBJS)

# --- Rules ---
all:			$(NAME)

$(NAME):		$(ALL_OBJS)
				ar rcs $(NAME) $(ALL_OBJS)

%.o: %.c
				@echo "libft: Compiling $<..."
				$(CC) $(CFLAGS) -c $< -o $@

$(FT_PRINTF_DIR)/%.o: $(FT_PRINTF_DIR)/%.c
				@echo "ft_printf: Compiling $<..."
				$(CC) $(CFLAGS) -c $< -o $@

$(GNL_DIR)/%.o: $(GNL_DIR)/%.c
				@echo "get_next_line: Compiling $<..."
				$(CC) $(CFLAGS) -c $< -o $@
	
clean:
				@echo "Cleaning object files..."
				$(RM) $(ALL_OBJS)

fclean:			clean
				@echo "Cleaning library archive..."
				$(RM) $(NAME)

re:				fclean $(NAME)

.PHONY:			all clean fclean re

# .SILENT


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_abs.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_abs.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 12:16:57 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/24 14:29:34 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

float	ft_abs_float(float nbr)
{
	if (nbr < 0)
		return (-nbr);
	else
		return (nbr);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_atoi.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 13:46:18 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/01 10:19:38 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        atoi, atol, atoll - convert a string to an integer
** 
** SYNOPSIS
**        #include <stdlib.h>
** 
**        int atoi(const char *nptr);
**        long atol(const char *nptr);
**        long long atoll(const char *nptr);
** 
**    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
** 
**        atoll():
**            _ISOC99_SOURCE ||
**                ||  Glibc versions <= 2.19:  _BSD_SOURCE || _SVID_SOURCE
*/

#include "libft.h"

int	ft_atoi(const char *str)
{
	int	result;
	int	sign;
	int	i;

	result = 0;
	sign = 1;
	i = 0;
	while (str[i] == ' ' || str[i] == '\t' || str[i] == '\n'
		|| str[i] == '\v' || str[i] == '\f' || str[i] == '\r')
		i++;
	if ((str[i] == '+') || (str[i] == '-'))
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	while ((str[i] >= '0') && (str[i] <= '9'))
	{
		result = (result * 10) + (str[i] - '0');
		i++;
	}
	return (sign * result);
}

/*
#include <stdio.h>


int main(void)
{
    const char *test_cases[] = {
        "42",
        "-42",
        "   +42",
        "   ---42",
        "4193 with words",
        "words and 987",
        "2147483647", // INT_MAX
        "-2147483648", // INT_MIN
        "2147483648", // Overflow
        "-2147483649", // Underflow
        "   +0",
		"----++++  -42", //+ and spaces
		"\t\v\f\r\n \f+\t\v\f\r\n \f1234",
        NULL
    };

    for (int i = 0; test_cases[i] != NULL; i++) {
        printf("\nTest %d\nInput: '%s'\nOriginal Output:%d\nlibftOutput: %d\n", 
		i, test_cases[i], atoi(test_cases[i]), ft_atoi(test_cases[i]));
    }

    printf("%d, %d",ft_atoi("\t\v\f\r\n \f+\t\v\f\r\n \f1234"),
	atoi("\t\v\f\r\n \f+\t\v\f\r\n \f1234"));

	int i1 = ft_atoi("\t\v\f\r\n \f+\t\v\f\r\n \f1234");
	int i2 = atoi("\t\v\f\r\n \f+\t\v\f\r\n \f1234");
	if (i1 == i2)
	{
		printf("\n1\n");
		return (1);
	}
    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_atoi_base.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi_base.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/23 19:43:42 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/23 19:44:41 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_convert_from_base(char *str, char *base)
{
	size_t	i;
	size_t	c;
	int		total;
	int		base_len;

	i = 0;
	total = 0;
	base_len = ft_strlen(base);
	while (str[i] && ft_strchr(base, ft_tolower(str[i])))
	{
		c = 0;
		while (base[c] != ft_tolower(str[i]) && base[c])
			c++;
		total = (total * base_len) + c;
		i++;
	}
	return (total);
}

int	ft_check_base_error(char *str)
{
	size_t	i;
	size_t	c;

	i = 0;
	if (ft_strlen(str) <= 1)
		return (0);
	while (str[i])
	{
		if (!ft_isprint(str[i]))
			return (0);
		c = 1;
		while (str[i + c])
		{
			if (str[i + c] == str[i])
				return (0);
			c++;
		}
		i++;
	}
	return (1);
}

int	ft_atoi_base(char *str, char *base)
{
	int		sign;
	int		total;
	size_t	i;

	if (!ft_check_base_error(base))
		return (0);
	sign = 1;
	total = 0;
	i = 0;
	while ((str[i] >= 9 && str[i] <= 13) || str[i] == 32)
		i++;
	if (str[i] == '+' || str[i] == '-')
	{
		if (str[i] == '-')
			sign *= (-1);
		i++;
	}
	if (str[i] == '0')
	{
		i++;
		if (str[i] == 'x')
			i++;
	}
	total = ft_convert_from_base(&str[i], base);
	return (total * sign);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_atol.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atol.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/01 11:32:17 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/01 12:03:47 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

// atol: ascii to long
#include "libft.h"
//#include <limits.h>

// (2^64)/2
//#define LONG_MAX 9223372036854775807
//#define LONG_MIN -9223372036854775808

long	ft_atol(const char *str)
{
	long	result;
	int		sign;
	int		i;

	result = 0;
	sign = 1;
	i = 0;
	while (str[i] == ' ' || str[i] == '\t' || str[i] == '\n'
		|| str[i] == '\v' || str[i] == '\f' || str[i] == '\r')
		i++;
	if ((str[i] == '+') || (str[i] == '-'))
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	while ((str[i] >= '0') && (str[i] <= '9'))
	{
		result = (result * 10) + (str[i] - '0');
		i++;
	}
	return (sign * result);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_bzero.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 10:42:00 by goteixei          #+#    #+#             */
/*   Updated: 2024/10/27 18:37:36 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

// bzero, explicit_bzero - zero a byte string

#include "libft.h"

void	*ft_bzero(void *s, size_t len)
{
	char	*p;

	p = (char *)s;
	while (len > 0)
	{
		p[len - 1] = '\0';
		len--;
	}
	return (s);
}

/*
#include <string.h>
#include <stdio.h>

int main()
{
    char str[50] = "Test1234567890text for bzero function";
    printf("\nBefore memset(): %s\n", str);

    // Fill some characters of the string
    ft_bzero(str + 5, '.', sizeof(char));
 
    printf("\nAfter ft_bzero(): %s\n", str);
    return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_calloc.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 19:00:11 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/10 22:31:57 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        malloc, free, calloc, realloc, reallocarray -
**        allocate and free dynamic memory
** 
** SYNOPSIS
**        #include <stdlib.h>
** 
**        void *malloc(size_t size);
**        void free(void *ptr);
**        void *calloc(size_t nmemb, size_t size);
**        void *realloc(void *ptr, size_t size);
**        void *reallocarray(void *ptr, size_t nmemb, size_t size);
** 
**    Feature Test Macro Requirements for glibc
**    (see feature_test_macros(7)):
** 
**        reallocarray():
**            Since glibc 2.29:
**                _DEFAULT_SOURCE
**            Glibc 2.28 and earlier:
**                _GNU_SOURCE
*/

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	ptr = malloc(nmemb * size);
	if (!ptr)
		return (NULL);
	ft_bzero(ptr, nmemb * size);
	return (ptr);
}

/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

int main()
{
    int *arr1 = (int *)ft_calloc(5, sizeof(int));
    if (arr1 != NULL && arr1[0] == 0 && arr1[4] == 0)
        printf("Test 1 Passed: Memory is initialized to zero\n");
    else
        printf("Test 1 Failed\n");
    free(arr1);

    char *arr2 = (char *)ft_calloc(5, sizeof(char));
    if (arr2 != NULL && arr2[0] == '\0' && arr2[4] == '\0')
        printf("Test 2 Passed: Memory is initialized to zero\n");
    else
        printf("Test 2 Failed\n");
    free(arr2);

    char *arr3 = (char *)ft_calloc(0, sizeof(char));
    if (arr3 != NULL)
        printf("Test 3 Passed: Allocation with zero size\n");
    else
        printf("Test 3 Failed\n");
    free(arr3);

    int *arr4 = (int *)ft_calloc(1000, sizeof(int));
    int is_zeroed = 1;
    for (size_t i = 0; i < 1000; i++)
    {
        if (arr4[i] != 0)
        {
            is_zeroed = 0;
            break;
        }
    }
    if (is_zeroed)
        printf("Test 4 Passed: Large memory block initialized to zero\n");
    else
        printf("Test 4 Failed\n");
    free(arr4);

    void *arr5 = ft_calloc(SIZE_MAX, SIZE_MAX);
    if (arr5 == NULL)
        printf("Test 5 Passed: Correctly handled allocation failure\n");
    else
    {
        printf("Test 5 Failed\n");
        free(arr5);
    }

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_error.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_error.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/01 12:02:56 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/24 14:43:14 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_error(const int error_code, char *error_message, int fd)
{
	ft_putendl_fd(error_message, fd);
	exit(error_code);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_isalnum.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 00:33:17 by goteixei          #+#    #+#             */
/*   Updated: 2024/10/24 00:33:17 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalnum(int c)
{
	if ((c >= 'a' && c <= 'z') || \
	(c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
		return (1);
	else
		return (0);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_isalpha.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 14:20:08 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/02 16:17:30 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
		return (1);
	else
		return (0);
}

/*
//#include "stdio.h"

int main() {
    printf("%d\n", ft_alpha(3));
    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_isascii.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 00:28:05 by goteixei          #+#    #+#             */
/*   Updated: 2024/10/24 00:28:05 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	else
		return (0);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_isdigit.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 00:05:31 by goteixei          #+#    #+#             */
/*   Updated: 2024/10/24 00:05:31 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	else
		return (0);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_isprint.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 00:35:50 by goteixei          #+#    #+#             */
/*   Updated: 2024/10/24 00:35:50 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//checks for any printable character including space

#include "libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	else
		return (0);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_itoa.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 16:34:05 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 18:12:23 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_itoa
** 
** Prototype
** char *ft_itoa(int n);
** 
** Turn in files
** -
** 
** Parameters
** n: the integer to convert.
** 
** Return value
** The string representing the integer.
** NULL if the allocation fails.
** 
** External functs.
** malloc
** 
** Description
** Allocates (with malloc(3)) and returns a string
** representing the integer received as an argument.
** Negative numbers must be handled.
*/

#include "libft.h"

size_t	str_len(const char *s)
{
	int	len;

	len = 0;
	while (s[len] != '\0')
	{
		len++;
	}
	return (len);
}

size_t	nbr_len(int n)
{
	size_t	len;

	len = 0;
	if (n == 0)
		return (1);
	if (n < 0)
	{
		n *= -1;
		len++;
	}
	while (n)
	{
		n /= 10;
		len++;
	}
	return (len);
}

char	*str_cpy(char *dest, char *src)
{
	char	*original_dest;

	original_dest = dest;
	while (*src != '\0')
	{
		*dest = *src;
		dest++;
		src++;
	}
	*dest = '\0';
	return (original_dest);
}

char	*str_join(char *s1, char *s2)
{
	size_t	s1_len;
	size_t	s2_len;
	char	*result;

	s1_len = str_len(s1);
	s2_len = str_len(s2);
	result = (char *)malloc((s1_len + s2_len + 1) * sizeof(char));
	if (result == NULL)
		return (NULL);
	str_cpy(result, s1);
	str_cpy(result + s1_len, s2);
	return (result);
}

char	*ft_itoa(int n)
{
	size_t	len;
	char	*result;
	long	number;

	number = n;
	len = nbr_len(number);
	result = (char *)malloc((len + 1) * sizeof(char));
	if (!result)
		return (NULL);
	result[len] = '\0';
	if (number < 0)
	{
		result[0] = '-';
		number *= -1;
	}
	if (number == 0)
		result[0] = '0';
	while (number > 0)
	{
		result[--len] = (number % 10) + '0';
		number /= 10;
	}
	return (result);
}

/*
#include <stdio.h>

int main(void)
{
	int test_nbrs[] = {5, 124, -4, -420, 0, -2147483648};
	int test_count = sizeof(test_nbrs) / sizeof(test_nbrs[0]);
	int test_i = 0;
	while (test_i < test_count)
	{
		char *result = ft_itoa(test_nbrs[test_i]);
		printf("Test %d: %d\nResult: %s\n\n", test_i, test_nbrs[test_i], result);
		//free(result);
		test_i++;
	}
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstadd_back.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 17:10:14 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:01:45 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstadd_back
** 
** Prototype
** void ft_lstadd_back(t_list **lst, t_list *new);
** 
** Turn in files
** -
** 
** Parameters
** lst: The address of a pointer to the first link of a list.
** new: The address of a pointer to the node to be added to the list.
** 
** Return value
** None
** 
** External functs.
** None
** 
** Description
** Adds the node ’new’ at the end of the list.
*/

#include "libft.h"

/**
 * ft_lstadd_back - Adds a new node at the end of the linked list.
 * @lst: The address of a pointer to the first link of a list.
 * @new: The address of a pointer to the node to be added to the list.
 */
void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*last_node;

	if (*lst == NULL)
	{
		*lst = new;
	}
	else
	{
		last_node = *lst;
		while (last_node->next != NULL)
		{
			last_node = last_node->next;
		}
		last_node->next = new;
	}
}

/*
#include <stdio.h>
#include <stdlib.h>

t_list *ft_lstnew(void *content) {
    t_list *new_node = (t_list *)malloc(sizeof(t_list));
    if (new_node == NULL) return NULL;
    new_node->content = content;
    new_node->next = NULL;
    return new_node;
}

void ft_lstadd_front(t_list **lst, t_list *new) {
    new->next = *lst;
    *lst = new;
}

void print_list(t_list *lst) {
    t_list *current = lst;
    while (current != NULL) {
        printf("Node content: %d\n", *(int *)current->content);
        current = current->next;
    }
}

int main() {
    t_list *head = NULL;

    int *value1 = malloc(sizeof(int)); *value1 = 42;
    t_list *node1 = ft_lstnew(value1);
    ft_lstadd_front(&head, node1);

    int *value2 = malloc(sizeof(int)); *value2 = 100;
    t_list *node2 = ft_lstnew(value2);
    ft_lstadd_front(&head, node2);

    int *value3 = malloc(sizeof(int)); *value3 = 200;
    t_list *node3 = ft_lstnew(value3);
    ft_lstadd_back(&head, node3);

    printf("Contents of the list:\n");
    print_list(head);

    t_list *current = head;
    while (current != NULL) {
        t_list *temp = current;
        current = current->next;
        free(temp->content);
        free(temp);
    }

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstadd_front.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 16:22:37 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:13:51 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstadd_front
** 
** Prototype
** void ft_lstadd_front(t_list **lst, t_list *new);
** 
** Turn in files
** -
** 
** Parameters
** lst: The address of a pointer to the first link of a list.
** new: The address of a pointer to the node to be
** added to the list.
** 
** Return value
** None
** 
** External functs.
** None
** 
** Description
** Adds the node ’new’ at the beginning of the list.
*/

#include "libft.h"

/**
 * ft_lstadd_front - Adds a node at the beginning of the list.
 * @lst: The address of a pointer to the first link of a list.
 * @new: The address of a pointer to the node to be added to the list.
 */

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	if (new == NULL)
		return ;
	new->next = *lst;
	*lst = new;
}

/*
t_list *ft_lstnew(void *content)
{
	t_list *new_node = (t_list *)malloc(sizeof(t_list));
	if (new_node == NULL)
		return (NULL);
	new_node->content = content;
	new_node->next = NULL;
	return new_node;
}
*/

/*
#include <stdio.h>

int main() {
    t_list *head = NULL;

    int *value1 = malloc(sizeof(int));
    *value1 = 42;
    t_list *node1 = ft_lstnew(value1);

    ft_lstadd_front(&head, node1);

    int *value2 = malloc(sizeof(int));
    *value2 = 100;
    t_list *node2 = ft_lstnew(value2);

    ft_lstadd_front(&head, node2);

    t_list *current = head;
    while (current != NULL) {
        printf("Node content: %d\n", *(int *)current->content);
        current = current->next;
    }

	free(node1);
	free(node2);
	free(head);

	current = head;
    while (current != NULL) {
        t_list *temp = current;
        current = current->next;
        free(temp->content);
        free(temp);
    }

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstclear.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 17:26:38 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/09 08:47:07 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstclear
** 
** Prototype
** void ft_lstclear(t_list **lst, void (*del)(void*));
** 
** Turn in files
** -
** 
** Parameters
** lst: The address of a pointer to a node.
** del: The address of the function used to delete the content of the node.
** 
** Return value
** None
** 
** External functs.
** free
** 
** Description
** Deletes and frees the given node and every
** successor of that node, using the function ’del’
** and free(3).
** Finally, the pointer to the list must be set to
** NULL.
*/

#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void*))
{
	t_list	*current;
	t_list	*next_node;

	current = *lst;
	if (lst == NULL || del == NULL)
		return ;
	while (current != NULL)
	{
		next_node = current->next;
		del(current->content);
		free(current);
		current = next_node;
	}
	*lst = NULL;
}

/*
void del_content(void *content) {
    free(content);
}

t_list *ft_lstnew(void *content) {
    t_list *new_node = (t_list *)malloc(sizeof(t_list));
    if (new_node == NULL) return NULL;
    new_node->content = content;
    new_node->next = NULL;
    return new_node;
}


#include <stdio.h>
#include <stdlib.h>

int main() {
    t_list *head = NULL;

    for (int i = 0; i < 3; i++) {
        int *value = malloc(sizeof(int));
        *value = (i + 1) * 10;
        t_list *new_node = ft_lstnew(value);
        new_node->next = head;
        head = new_node;
    }

    ft_lstclear(&head, del_content);

    if (head == NULL) {
        printf("List cleared successfully.\n");
    } else {
        printf("List not cleared.\n");
    }

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstdelone.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 17:19:49 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/02 21:53:16 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstdelone
** 
** Prototype
** void ft_lstdelone(t_list *lst, void (*del)(void*));
** 
** Turn in files
** -
** 
** Parameters
** lst: The node to free.
** del: The address of the function used to delete the content.
** 
** Return value
** None
** 
** External functs.
** free
** 
** Description
** Takes as a parameter a node and frees the memory of
** the node’s content using the function ’del’ given
** as a parameter and free the node. The memory of
** ’next’ must not be freed.
*/

#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void*))
{
	if (lst == NULL || del == NULL)
		return ;
	del(lst->content);
	free(lst);
}

/*
#include <stdio.h>
#include <stdlib.h>

void del_content(void *content) {
    free(content);
}

t_list *ft_lstnew(void *content) {
    t_list *new_node = (t_list *)malloc(sizeof(t_list));
    if (new_node == NULL) return NULL;
    new_node->content = content;
    new_node->next = NULL;
    return new_node;
}

int main() {
    t_list *node = ft_lstnew(malloc(sizeof(int)));
    *(int *)node->content = 42;

    printf("Node content before deletion: %d\n", *(int *)node->content);
    
    ft_lstdelone(node, del_content);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstiter.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 15:17:43 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:01:04 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstiter
** 
** Prototype
** void ft_lstiter(t_list *lst, void (*f)(void *));
** 
** Turn in files
** -
** 
** Parameters
** lst: The address of a pointer to a node.
** f: The address of the function used to iterate on the list.
** 
** Return value
** None
** 
** External functs.
** None
** 
** Description
** Iterates the list ’lst’ and applies the function ’f’
** on the content of each node.
*/

#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	while (lst != NULL)
	{
		f(lst->content);
		lst = lst->next;
	}
}

/*
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void print_content(void *content) {
    printf("Node content: %d\n", *(int *)content); // Print integer content
}

t_list *ft_lstnew(void *content) {
    t_list *new_node = (t_list *)malloc(sizeof(t_list));
    if (new_node == NULL) return NULL;
    new_node->content = content;
    new_node->next = NULL;
    return new_node;
}

int main() {
    t_list *head = NULL;

    for (int i = 1; i <= 3; i++) {
        int *value = malloc(sizeof(int));
        *value = i * 10;
        t_list *new_node = ft_lstnew(value);
        new_node->next = head;
        head = new_node;
    }

    printf("Contents of the list:\n");
    ft_lstiter(head, print_content);

    t_list *current = head;
    while (current != NULL) {
        t_list *temp = current;
        current = current->next;
        free(temp->content);
        free(temp);
    }

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstlast.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 16:57:44 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 00:51:33 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstlast
** 
** Prototype
** t_list *ft_lstlast(t_list *lst);
** 
** Turn in files
** -
** 
** Parameters lst:
** The beginning of the list.
** 
** Return value
** Last node of the list
** 
** External functs.
** None
** 
** Description
** Returns the last node of the list.
*/

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (lst == NULL)
	{
		return (NULL);
	}
	while (lst->next != NULL)
	{
		lst = lst->next;
	}
	return (lst);
}

/*
#include <stdio.h>

int ft_lstsize(t_list *lst)
{
	int count;

	count = 0;

	while (lst != NULL)
	{
		count++;
		lst = lst->next;
	}
	return count;
}

t_list *ft_lstnew(void *content)
{
	t_list *new_node = (t_list *)malloc(sizeof(t_list));
	if (new_node == NULL)
		return (NULL);
	new_node->content = content;
	new_node->next = NULL;
	return new_node;
}

void ft_lstadd_front(t_list **lst, t_list *new)
{
	if (new == NULL)
		return;
	new->next = *lst;
	*lst = new;
}

void print_list(t_list *lst) {
    t_list *current = lst;
    while (current != NULL) {
        printf("- Node content: %d\n", *(int *)current->content);
        current = current->next;
    }
}

int main() {
    t_list *head = NULL;

    int *value1 = malloc(sizeof(int)); *value1 = 42;
    t_list *node1 = ft_lstnew(value1);
    ft_lstadd_front(&head, node1);

    int *value2 = malloc(sizeof(int)); *value2 = 100;
    t_list *node2 = ft_lstnew(value2);
    ft_lstadd_front(&head, node2);

    int *value3 = malloc(sizeof(int)); *value3 = 200;
    t_list *node3 = ft_lstnew(value3);
    ft_lstadd_front(&head, node3);

    int size = ft_lstsize(head);
    printf("The size of the list is: %d\n", size);

    printf("Contents of the list:\n");
    print_list(head);

    t_list *last_node = ft_lstlast(head);
    if (last_node != NULL) {
        printf("The last node content is: %d\n", *(int *)last_node->content);
    } else {
        printf("The list is empty.\n");
    }

    t_list *current = head;
    while (current != NULL) {
        t_list *temp = current;
        current = current->next;
        free(temp->content);
        free(temp);
    }

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstmap.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 15:36:03 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/09 09:03:17 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstmap
** 
** Prototype
** t_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));
** 
** Turn in files
** -
** 
** Parameters
** lst: The address of a pointer to a node.
** f: The address of the function used to iterate on the list.
** del: The address of the function used to delete
** the content of a node if needed.
** 
** Return value
** The new list.
** NULL if the allocation fails.
** 
** External functs.
** malloc, free
** 
** Description
** Iterates the list ’lst’ and applies the function
** ’f’ on the content of each node. Creates a new
** list resulting of the successive applications of
** the function ’f’. The ’del’ function is used to
** delete the content of a node if needed.
*/

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new_list;
	t_list	*new_node;
	void	*new_content;

	new_list = NULL;
	while (lst != NULL)
	{
		new_content = f(lst->content);
		if (new_content == NULL)
		{
			ft_lstclear(&new_list, del);
			return (NULL);
		}
		new_node = ft_lstnew(new_content);
		if (new_node == NULL)
		{
			del(new_content);
			ft_lstclear(&new_list, del);
			return (NULL);
		}
		ft_lstadd_back(&new_list, new_node);
		lst = lst->next;
	}
	return (new_list);
}

/*
#include <stdio.h>
#include <stdlib.h>

void *double_content(void *content) {
    int *new_content = malloc(sizeof(int));
    *new_content = (*(int *)content) * 2;
    return new_content;
}

void delete_content(void *content) {
    free(content);
}

void ft_lstclear(t_list **lst, void (*del)(void*))
{
	if (lst == NULL || del == NULL)
		return;

	t_list *current = *lst;
	t_list *next_node;

	while (current != NULL)
	{
		next_node = current->next;
		del(current->content);
		free(current);
		current = next_node;
	}
	*lst = NULL;
}
void ft_lstadd_back(t_list **lst, t_list *new)
{
	if (*lst == NULL)
	{
		*lst = new;
	}
	else
	{
		t_list *last_node = *lst;
		while (last_node->next != NULL)
		{
			last_node = last_node->next;
		}
		last_node->next = new;
	}
}

t_list *ft_lstnew(void *content)
{
	t_list *new_node = (t_list *)malloc(sizeof(t_list));
	if (new_node == NULL)
		return (NULL);
	new_node->content = content;
	new_node->next = NULL;
	return new_node;
}

void print_list(t_list *lst) {
    while (lst != NULL) {
        printf("Node content: %d\n", *(int *)lst->content);
        lst = lst->next;
    }
}

int main() {
    t_list *head = NULL;

    for (int i = 1; i <= 3; i++) {
        int *value = malloc(sizeof(int));
        *value = i * 10;
        t_list *node = ft_lstnew(value);
        ft_lstadd_back(&head, node);
    }

    t_list *mapped_list = ft_lstmap(head, double_content, delete_content);

    printf("Original list:\n");
    print_list(head);

    printf("\nMapped list (content doubled):\n");
    print_list(mapped_list);

    ft_lstclear(&head, delete_content);
    ft_lstclear(&mapped_list, delete_content);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstnew.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 15:58:58 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/02 22:01:02 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstnew
** 
** Prototype
** t_list *ft_lstnew(void *content);
** 
** Turn in files
** -
** 
** Parameters content:
** The content to create the node with.
** 
** Return value
** The new node
** 
** External functs.
** malloc
** 
** Description
** Allocates (with malloc(3)) and returns a new node.
** The member variable ’content’ is initialized with
** the value of the parameter ’content’. The variable
** ’next’ is initialized to NULL.
*/

#include "libft.h"

/**
 * ft_lstnew - Allocates and returns a new node.
 * @content: The content to create the node with.
 *
 * Return: The new node, or NULL if allocation fails.
 */
t_list	*ft_lstnew(void *content)
{
	t_list	*new_node;

	new_node = (t_list *)malloc(sizeof(t_list));
	if (new_node == NULL)
		return (NULL);
	new_node->content = content;
	new_node->next = NULL;
	return (new_node);
}

/*
#include <stdio.h>

int main()
{
    int value = 42;
    t_list *node = ft_lstnew(&value);

    if (node != NULL)
    {
        printf("Node created with content: %d\n", *(int *)node->content);
        free(node); // Don't forget to free allocated memory
    }
    else
    {
        printf("Failed to create node.\n");
    }

    return 0;
}
*/

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_lstsize.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 16:44:56 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:11:41 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_lstsize
** 
** Prototype
** int ft_lstsize(t_list *lst);
** 
** Turn in files
** -
** 
** Parameters lst:
** The beginning of the list.
** 
** Return value
** The length of the list
** 
** External functs.
** None
** 
** Description
** Counts the number of nodes in a list.
*/

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	int	count;

	count = 0;
	while (lst != NULL)
	{
		count++;
		lst = lst->next;
	}
	return (count);
}

/*
t_list *ft_lstnew(void *content)
{
	t_list *new_node = (t_list *)malloc(sizeof(t_list));
	if (new_node == NULL)
		return (NULL);
	new_node->content = content;
	new_node->next = NULL;
	return new_node;
}

void ft_lstadd_front(t_list **lst, t_list *new)
{
	if (new == NULL)
		return;
	new->next = *lst;
	*lst = new;
}

#include <stdio.h>


void print_list(t_list *lst) {
    t_list *current = lst;
    while (current != NULL) {
        printf("Node content: %d\n", *(int *)current->content);
        current = current->next;
    }
}

int main() {
    t_list *head = NULL;

    int *value1 = malloc(sizeof(int)); *value1 = 42;
    t_list *node1 = ft_lstnew(value1);
    ft_lstadd_front(&head, node1);

    int *value2 = malloc(sizeof(int)); *value2 = 100;
    t_list *node2 = ft_lstnew(value2);
    ft_lstadd_front(&head, node2);

    int *value3 = malloc(sizeof(int)); *value3 = 200;
    t_list *node3 = ft_lstnew(value3);
    ft_lstadd_front(&head, node3);

    int size = ft_lstsize(head);
    printf("The size of the list is: %d\n", size);

    printf("Contents of the list:\n");
    print_list(head);

    t_list *current = head;
    while (current != NULL) {
        t_list *temp = current;
        current = current->next;
        free(temp->content);
        free(temp);
    }

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_max.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_max.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 12:17:50 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/24 12:18:14 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

float	ft_max_float(float a, float b)
{
	if (a > b)
		return (a);
	else
		return (b);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_memchr.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 17:05:10 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:12:57 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        memchr, memrchr, rawmemchr - scan memory for a character
** 
** SYNOPSIS
**        #include <string.h>
** 
**        void *memchr(const void *s, int c, size_t n);
** 
**        void *memrchr(const void *s, int c, size_t n);
** 
**        void *rawmemchr(const void *s, int c);
** 
**    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
** 
**        memrchr(), rawmemchr(): _GNU_SOURCE
*/

#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t				i;
	const unsigned char	*ptr;
	unsigned char		cha;

	i = 0;
	ptr = (const unsigned char *)s;
	cha = (unsigned char)c;
	while (i < n)
	{
		if (ptr[i] == cha)
		{
			return ((void *)(ptr + i));
		}
		i++;
	}
	return (NULL);
}

/*
#include <stdio.h>

int main()
{
    const char *test_str = "Hello, world!";
    size_t len = strlen(test_str);

    // Test 1: Find a character in the middle
    char *result = ft_memchr(test_str, 'o', len);
	printf("Result: %ld\n", result);
	printf("Test_str: %ld\n", test_str);
    if (result) {
        printf("Test 1 Passed: Found 'o' at position: %ld\n", result - test_str);
    } else {
        printf("Test 1 Failed: 'o' not found.\n");
    }

    // Test 2: Find a character at the beginning
    result = ft_memchr(test_str, 'H', len);
    if (result) {
        printf("Test 2 Passed: Found 'H' at position: %ld\n", result - test_str);
    } else {
        printf("Test 2 Failed: 'H' not found.\n");
    }

    // Test 3: Find a character at the end
    result = ft_memchr(test_str, '!', len);
    if (result) {
        printf("Test 3 Passed: Found '!' at position: %ld\n", result - test_str);
    } else {
        printf("Test 3 Failed: '!' not found.\n");
    }

    // Test 4: Find a character that does not exist
    result = ft_memchr(test_str, 'x', len);
    if (!result) {
        printf("Test 4 Passed: 'x' not found as expected.\n");
    } else {
        printf("Test 4 Failed: 'x' found at position: %ld\n", result - test_str);
    }

    // Test 5: Search an empty string
    const char *empty_str = "";
    result = ft_memchr(empty_str, 'a', 0);
    if (!result) {
        printf("Test 5 Passed: No character found in an empty string.\n");
    } else {
        printf("Test 5 Failed: Found character in an empty string.\n");
    }
	return(0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_memcmp.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 17:25:02 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:19:45 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        memcmp - compare memory areas
** 
** SYNOPSIS
**        #include <string.h>
** 
**        int memcmp(const void *s1, const void *s2, size_t n);
*/

#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t				i;
	const unsigned char	*ptr1;
	const unsigned char	*ptr2;

	i = 0;
	ptr1 = (unsigned char *)s1;
	ptr2 = (unsigned char *)s2;
	while (i < n)
	{
		if (ptr1[i] != ptr2[i])
		{
			return (ptr1[i] - ptr2[i]);
		}
		i++;
	}
	return (0);
}

/*
#include <stdio.h>
#include <string.h>

int main()
{
    const char *str1 = "Hello, world!";char
    const char *str2 = "Hello, world!";
    int result = ft_memcmp(str1, str2, strlen(str1));
    printf("Test 1: %s\n", result == 0 ? "Passed" : "Failed");

    const char *str3 = "Hello, world!";
    const char *str4 = "Hello, there!";
    result = ft_memcmp(str3, str4, strlen(str3));
    printf("Test 2: %s\n", result != 0 ? "Passed" : "Failed");

    const char *str5 = "abc";
    const char *str6 = "abd";
    result = ft_memcmp(str5, str6, 3);
    printf("Test 3: %s\n", result < 0 ? "Passed" : "Failed");

    const char *str7 = "abd";
    const char *str8 = "abc";
    result = ft_memcmp(str7, str8, 3);
    printf("Test 4: %s\n", result > 0 ? "Passed" : "Failed");

    const char *str9 = "abc";
    const char *str10 = "ab";
    result = ft_memcmp(str9, str10, 2);
    printf("Test 5: %s\n", result == 0 ? "Passed" : "Failed");

    const char *empty1 = "";
    const char *empty2 = "";
    result = ft_memcmp(empty1, empty2, 0);
    printf("Test 6: %s\n", result == 0 ? "Passed" : "Failed");char
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_memcpy.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 11:38:35 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 21:51:01 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

// memcpy - copy memory area

#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	char		*temp_dest;
	const char	*temp_src;

	if (!dest && !src)
		return (0);
	temp_dest = (char *)dest;
	temp_src = (const char *)src;
	while (n--)
	{
		*temp_dest++ = *temp_src++;
	}
	return (dest);
}

/*
#include <stddef.h>
#include <stdio.h>

int main()
{
    char str1[] = "Test1234567890text for memset function";
	char str2[100];
    printf("\nSource: %s\n", str1);

    // Function usage
    ft_memcpy(str2, str1, sizeof(str1)+1);
 
    printf("\nDestination using ft_memcpy(): %s\n", str2);
    return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_memmove.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 12:48:30 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 22:11:16 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        memmove - copy memory area
** 
** SYNOPSIS
**        #include <string.h>
** 
**        void *memmove(void *dest, const void *src, size_t n);
** 
** DESCRIPTION
**        The memmove() function copies n bytes from memory
**         area src to memory area dest.
**        The memory areas may overlap: copying takes place
**        as though the  bytes  in  src are  first copied into
**        a temporary array that does not overlap src or dest, and
**        the bytes are then copied from the temporary array to dest.
** 
** RETURN VALUE
**        The memmove() function returns a pointer to dest.
*/

#include "libft.h"

void	*ft_memmove(void *dst, const void *src, size_t n)
{
	char	*s;
	char	*d;
	size_t	i;

	if (!dst && !src)
		return (NULL);
	s = (char *)src;
	d = (char *)dst;
	i = 0;
	if (d > s)
	{
		while (n-- > 0)
		{
			d[n] = s[n];
		}
	}
	else
	{
		while (i < n)
		{
			d[i] = s[i];
			i++;
		}
	}
	return (dst);
}

/*
#include <stddef.h>
#include <stdio.h>

int main()
{
	char str1[] = "Test1234567890text for ft_memmove function";
	char str2[100];
	printf("\nSource: %s\n", str1);

	// Function usage
	ft_memmove(str2, str1, sizeof(str1));

	printf("\nDestination using ft_memmove(): %s\n", str2);
	return (0);
}
*/

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_memset.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 08:43:26 by goteixei          #+#    #+#             */
/*   Updated: 2024/10/25 11:30:30 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

// memset - fill memory with a constant byte

#include "libft.h"

void	*ft_memset(void *s, int c, size_t len)
{
	char	*p;

	p = (char *)s;
	while (len > 0)
	{
		p[len - 1] = c;
		len--;
	}
	return (s);
}

/*
#include <string.h>
#include <stdio.h>

int main()
{
    char str[50] = "Test1234567890text for memset function";
    printf("\nBefore memset(): %s\n", str);

    // Fill some characters of the string
    ft_memset(str + 5, '.', sizeof(char));
 
    printf("\nAfter ft_memset(): %s\n", str);
    return (0);
}
*/

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_min.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_min.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 12:18:24 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/24 12:18:42 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

float	ft_min_float(float a, float b)
{
	if (a < b)
		return (a);
	else
		return (b);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/Makefile
--------------------------------------------------
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/11/15 12:01:49 by goteixei          #+#    #+#              #
#    Updated: 2025/04/07 11:37:22 by goteixei         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

SRCS	= ft_printf.c\
		ft_print_char.c\
		ft_print_str.c\
		ft_print_ptr.c\
		ft_print_unsigned.c\
		ft_print_hex.c\
		ft_print_int.c\
		ft_print_percent.c

OBJS	= $(SRCS:.c=.o)

CC				= cc
RM				= rm -f 
CFLAGS			= -Wall -Wextra -Werror
NAME			= libftprintf.a

all:			$(NAME)

$(NAME):		$(OBJS)
				ar rcs $(NAME) $(OBJS)

%.o: %.c
				$(CC) $(CFLAGS) -c $< -o $@

clean:			
				$(RM) $(OBJS)

fclean:			clean
				$(RM) $(NAME)

re:				fclean all

.PHONY:			all clean fclean re

# .SILENT:


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_print_char.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_char.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 20:16:06 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/15 16:20:19 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_print_char(int c)
{
	write(1, &c, 1);
	return (1);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_print_hex.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_hex.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 10:07:59 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/15 16:31:18 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	ft_hex_len(unsigned int nbr)
{
	int	len;

	len = 0;
	while (nbr != 0)
	{
		nbr /= 16;
		len++;
	}
	return (len);
}

static void	ft_put_hex(unsigned int nbr, const char format)
{
	int	len;

	len = 0;
	if (nbr >= 16)
	{
		ft_put_hex(nbr / 16, format);
		ft_put_hex(nbr % 16, format);
	}
	if (nbr < 16)
	{
		if (format == 'x')
			len += write(1, &"0123456789abcdef"[nbr], 1);
		if (format == 'X')
			len += write(1, &"0123456789ABCDEF"[nbr], 1);
	}
}

int	ft_print_hex(unsigned int nbr, const char format)
{
	if (nbr == 0)
	{
		return (write(1, "0", 1));
	}
	else
		ft_put_hex(nbr, format);
	return (ft_hex_len(nbr));
}

/*
#include <stdio.h>

int main(void)
{
	int	len_original;
	int	len_new;

	len_original = 0;
	len_new = 0;

	printf("\nTEST x\n");
	printf("Testing: (\"\\tThe hex number %%x is visible.\\n\", 4242)\n");
	len_original += printf("Original: \tthe hex number %x is visible.\n", 4242);
	len_new += ft_printf("ft_printf: \tthe hex number %x is visible.\n", 4242);
	printf("Printf = %d, ft_printf = %d\n\n", len_original, len_new);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_print_int.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_int.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 11:31:20 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/15 16:31:09 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	ft_nbr_len(int n)
{
	int	len;

	len = 0;
	if (n == 0)
		return (1);
	if (n < 0)
	{
		n = -n;
		len++;
	}
	while (n > 0)
	{
		n /= 10;
		len++;
	}
	return (len);
}

static void	ft_put_int(int n)
{
	static char	digits[] = "0123456789";

	if (n > 9)
		ft_put_int(n / 10);
	write(1, (&digits[n % 10]), 1);
}

int	ft_print_int(int n)
{
	int	len;

	if (n == -2147483648)
	{
		write(1, "-2147483648", 11);
		return (11);
	}
	len = ft_nbr_len(n);
	if (n < 0)
	{
		write(1, "-", 1);
		n *= -1;
	}
	ft_put_int(n);
	return (len);
}

/*
#include <stdio.h>

int main(void)
{
	int test_number = -1;
	printf("Print result: \n");
	printf("Result length:\n%d", ft_print_int(test_number));
	printf("\n");
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_print_percent.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_percent.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 20:18:06 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/15 16:20:29 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	ft_print_percent(void)
{
	write (1, "%", 1);
	return (1);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_print_ptr.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_ptr.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 12:00:55 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/15 16:31:03 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	ft_ptr_len(unsigned long long n)
{
	size_t	len;

	len = 0;
	if (n == 0)
		return (1);
	while (n != 0)
	{
		len += 1;
		n /= 16;
	}
	return (len);
}

static void	ft_put_ptr(unsigned long long n)
{
	static char	hex[] = "0123456789abcdef";

	if (n >= 16)
	{
		ft_put_ptr(n / 16);
		ft_put_ptr(n % 16);
	}
	if (n < 16)
	{
		write(1, &hex[n], 1);
	}
}

int	ft_print_ptr(unsigned long long *ptr)
{
	int	len;

	if (ptr == NULL)
		return (write(1, "(nil)", 5));
	len = ft_ptr_len((unsigned long long)ptr);
	write(1, "0x", 2);
	ft_put_ptr((unsigned long long) ptr);
	return (2 + len);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_print_str.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_str.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 11:29:52 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/15 16:30:56 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	ft_str_len(char const *str)
{
	int	i;

	i = 0;
	while (str[i] != '\0')
	{
		i++;
	}
	return (i);
}

int	ft_print_str(char const *str)
{
	if (str == NULL)
		return (write(1, "(null)", 6));
	else
		return (write(1, str, ft_str_len(str)));
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_print_unsigned.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_unsigned.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 11:46:55 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/07 11:08:23 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	ft_uns_len(unsigned int n)
{
	int	len;

	len = 0;
	if (n == 0)
		return (1);
	while (n > 0)
	{
		n /= 10;
		len++;
	}
	return (len);
}

static void	ft_put_uns(unsigned int n)
{
	static char	digits[] = "0123456789";

	if (n > 9)
		ft_put_uns(n / 10);
	write(1, &digits[n % 10], 1);
}

int	ft_print_unsigned(unsigned int n)
{
	int	len;

	len = ft_uns_len(n);
	ft_put_uns(n);
	return (len);
}

/*
#include <stdio.h>

int main(void)
{
	unsigned int test_number = -2147483648;
	printf("Print result: \n");
	printf("Result length:\n%d", ft_print_unsigned(test_number));
	printf("\n");
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_printf.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 23:44:34 by goteixei          #+#    #+#             */
/*   Updated: 2024/12/13 14:38:58 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	ft_formats(va_list args, const char format)
{
	int	len;

	len = 0;
	if (format == 'c')
		len += ft_print_char(va_arg(args, int));
	else if (format == 's')
		len += ft_print_str(va_arg(args, char *));
	else if (format == 'p')
		len += ft_print_ptr(va_arg(args, unsigned long long *));
	else if (format == 'u')
		len += ft_print_unsigned(va_arg(args, unsigned int));
	else if (format == 'd' || format == 'i')
		len += ft_print_int(va_arg(args, int));
	else if (format == 'x' || format == 'X')
		len += ft_print_hex(va_arg(args, unsigned int), format);
	else if (format == '%')
		len += ft_print_percent();
	return (len);
}

int	ft_printf(const char *str, ...)
{
	int		i;
	int		len;
	va_list	args;

	va_start(args, str);
	i = 0;
	len = 0;
	while (str[i])
	{
		if (str[i] != '%')
		{
			len += ft_print_char(str[i]);
		}
		else
		{
			len += ft_formats(args, str[i + 1]);
			i++;
		}
		i++;
	}
	va_end(args);
	return (len);
}

/*
#include <stdio.h>

int main(void)
{
    int custom_ret, original_ret;
    int test_number = 0;

    //NO SPECIFIERS TESTS 
    printf("========== NO SPECIFIERS TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("Hello World\n");
    original_ret = printf("Hello World\n");
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //PERCENT SIGN TESTS
    printf("========== PERCENT SIGN TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%%\n");
    original_ret = printf("%%\n");
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //CHAR TESTS
    printf("========== CHAR TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%c\n", 'A');
    original_ret = printf("%c\n", 'A');
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //STRING TESTS
    printf("========== STRING TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%s\n", "Test String");
    original_ret = printf("%s\n", "Test String");
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //INTEGER TESTS
    printf("========== INTEGER TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%d\n", 12345);
    original_ret = printf("%d\n", 12345);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //UNSIGNED TESTS
    printf("========== UNSIGNED TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%u\n", 4294967295U);
    original_ret = printf("%u\n", 4294967295U);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //HEXADECIMAL (LOWERCASE) TESTS
    printf("========== HEXADECIMAL x TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%x\n", 255);
    original_ret = printf("%x\n", 255);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //HEXADECIMAL (UPPERCASE) TESTS
    printf("========== HEXADECIMAL X TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%X\n", 255);
    original_ret = printf("%X\n", 255);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //POINTER TESTS
    printf("========== POINTER TESTS ==========");
    test_number++;
    int num = 42;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%p\n", &num);
    original_ret = printf("%p\n", &num);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //MIXED TESTS
    printf("========== MIXED TESTS ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("Char: %c, String: %s, Int: %d, Unsigned: %u, \
Hex: %x\n", 'B', "Mix", -123, 123U, 0xABC);
    original_ret = printf("Char: %c, String: %s, Int: %d, Unsigned: %u, \
Hex: %x\n", 'B', "Mix", -123, 123U, 0xABC);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //EDGE CASE TESTS

    //Large Integer
    printf("========== LARGE INTEGER ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%d\n", 2147483647);
    original_ret = printf("%d\n", 2147483647);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //Long String
    printf("========== LONG STRING ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%s\n", "This is a very long string designed \
to test the printf function's handling of substantial input without failing.");
    original_ret = printf("%s\n", "This is a very long string designed \
to test the printf function's handling of substantial input without failing.");
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    //Complex String Formatting
    printf("========== COMPLEX STRING FORMATTING ==========");
    test_number++;
    printf("\nTest %d:\n", test_number);
    custom_ret = ft_printf("%% Complete: %d%%\n", 75);
    original_ret = printf("%% Complete: %d%%\n", 75);
    printf("Custom: %d | Original: %d\n", custom_ret, original_ret);
    printf("------------------------------------------\n");

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_printf/ft_printf.h
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 23:37:59 by goteixei          #+#    #+#             */
/*   Updated: 2024/12/13 00:26:09 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FT_PRINTF_H
# define FT_PRINTF_H

# include <stdio.h>
# include <stdarg.h>
# include <limits.h>
# include <unistd.h>

int			ft_printf(const char *format, ...);

// c
int			ft_print_char(int c);

// s
int			ft_print_str(char const *str);

// p
//static int			ft_ptr_len(unsigned long long n);
//static void	ft_put_ptr(unsigned long long n);
int			ft_print_ptr(unsigned long long *ptr);

//u
//int			ft_uns_len(unsigned int n);
//static void	ft_put_uns(int n);
int			ft_print_unsigned(unsigned int n);
//int	ft_print_unsigned(unsigned int nbr);

// i, d
//int			ft_nbr_len(int n);
//static void	ft_put_int(int n);
int			ft_print_int(int n);

// x, X
//int			ft_hex_len(unsigned int nbr);
//void		ft_put_hex(unsigned int nbr, const char format);
int			ft_print_hex(unsigned int nbr, const char format);

//%
int			ft_print_percent(void);

#endif

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_putchar.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 15:17:52 by goteixei          #+#    #+#             */
/*   Updated: 2025/01/05 18:00:44 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_putchar_fd
** 
** Prototype
** void ft_putchar_fd(char c, int fd);
** 
** Turn in files
** -
** 
** Parameters
** c: The character to output.
** fd: The file descriptor on which to write.
** 
** Return value
** None
** 
** External functs.
** write
**
** Description Outputs the character ’c’ to the given file
** descriptor.
*/

#include "libft.h"

void	ft_putchar(char c)
{
	write(1, &c, 1);
}

/*
#include <stdio.h>

int main() {
    ft_putchar_fd('A', 1);

    fflush(stdout);

    ft_putchar_fd('B', 2);

    ft_putchar_fd('\n', 1);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_putchar_fd.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 15:17:52 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 16:09:51 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_putchar_fd
** 
** Prototype
** void ft_putchar_fd(char c, int fd);
** 
** Turn in files
** -
** 
** Parameters
** c: The character to output.
** fd: The file descriptor on which to write.
** 
** Return value
** None
** 
** External functs.
** write
**
** Description Outputs the character ’c’ to the given file
** descriptor.
*/

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}

/*
#include <stdio.h>

int main() {
    ft_putchar_fd('A', 1);

    fflush(stdout);

    ft_putchar_fd('B', 2);

    ft_putchar_fd('\n', 1);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_putendl.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/04 16:41:57 by goteixei          #+#    #+#             */
/*   Updated: 2025/01/05 18:02:42 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putendl(char const *s)
{
	ft_putstr(s);
	ft_putchar('\n');
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_putendl_fd.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 15:32:18 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 15:10:21 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_putendl_fd
** 
** Prototype
** void ft_putendl_fd(char *s, int fd);
** 
** Turn in files
** -
** 
** Parameters
** s: The string to output.
** fd: The file descriptor on which to write.
** 
** Return value
** None
** 
** External functs.
** write
** 
** Description
** Outputs the string ’s’ to the given file descriptor
** followed by a newline.
*/

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	int	i;

	i = 0;
	if (s == NULL)
		return ;
	while (s[i] != '\0')
	{
		write(fd, &s[i], 1);
		i++;
	}
	write(fd, "\n", 1);
}

/*
#include <stdio.h>

int main()
{
    printf("Testing ft_putendl_fd with standard output:\n");
    ft_putendl_fd("asdsfsafsa", 1);

    printf("Testing ft_putendl_fd with standard error:\n");
    ft_putendl_fd("B", 2);

    printf("Testing ft_putendl_fd with newline:\n");
    ft_putendl_fd("\n", 1);

    printf("Testing NULL input:\n");
    ft_putendl_fd(NULL, 1);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_putnbr_fd.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 15:44:33 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 15:12:29 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_putnbr_fd
** 
** Prototype
** void ft_putnbr_fd(int n, int fd);
** 
** Turn in files
** -
** 
** Parameters
** n: The integer to output.
** fd: The file descriptor on which to write.
** 
** Return value
** None
** 
** External functs.
** write
** 
** Description
** Outputs the integer ’n’ to the given file
** descriptor.
*/

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	char	last_number;

	if (n == -2147483648)
	{
		write(fd, "-2147483648", 11);
		return ;
	}
	if (n < 0)
	{
		write(fd, "-", 1);
		n = -n;
	}
	if (n >= 10)
	{
		ft_putnbr_fd(n / 10, fd);
	}
	last_number = (n % 10) + '0';
	write(fd, &last_number, 1);
}

/*
#include <stdio.h>

int main() {
    printf("Testing ft_putnbr_fd with positive integer:\n");
    ft_putnbr_fd(12345, 1);
    write(1, "\n", 1);

    printf("Testing ft_putnbr_fd with negative integer:\n");
    ft_putnbr_fd(-6789, 1);
    write(1, "\n", 1);

    printf("Testing ft_putnbr_fd with zero:\n");
    ft_putnbr_fd(0, 1);
    write(1, "\n", 1);

    printf("Testing ft_putnbr_fd with minimum integer:\n");
    ft_putnbr_fd(-2147483648, 1);
    write(1, "\n", 1);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_putstr.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 15:26:25 by goteixei          #+#    #+#             */
/*   Updated: 2025/01/05 18:04:40 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_putstr_fd
** 
** Prototype
** void ft_putstr_fd(char *s, int fd);
** 
** Turn in files
** -
** 
** Parameters
** s: The string to output.
** fd: The file descriptor on which to write.
** 
** Return value
** None
** 
** External functs.
** write
** 
** Description
** Outputs the string ’s’ to the given file
** descriptor.
*/

#include "libft.h"

void	ft_putstr(const char *s)
{
	int	i;

	i = 0;
	if (s == NULL)
		return ;
	while (s[i] != '\0')
	{
		write(1, &s[i], 1);
		i++;
	}
}

/*
#include <stdio.h>

int main()
{
    ft_putstr_fd("asdsfsafsa", 1);

    fflush(stdout);

    ft_putstr_fd("", 2);

    ft_putstr_fd("\n", 1);

    printf("Testing NULL input:\n");
    ft_putstr_fd(NULL, 1);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_putstr_fd.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 15:26:25 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 15:23:56 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_putstr_fd
** 
** Prototype
** void ft_putstr_fd(char *s, int fd);
** 
** Turn in files
** -
** 
** Parameters
** s: The string to output.
** fd: The file descriptor on which to write.
** 
** Return value
** None
** 
** External functs.
** write
** 
** Description
** Outputs the string ’s’ to the given file
** descriptor.
*/

#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	int	i;

	i = 0;
	if (s == NULL)
		return ;
	while (s[i] != '\0')
	{
		write(fd, &s[i], 1);
		i++;
	}
}

/*
#include <stdio.h>

int main()
{
    ft_putstr_fd("asdsfsafsa", 1);

    fflush(stdout);

    ft_putstr_fd("", 2);

    ft_putstr_fd("\n", 1);

    printf("Testing NULL input:\n");
    ft_putstr_fd(NULL, 1);

    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_split.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 13:00:47 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/24 14:42:17 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_split
** 
** Prototype
** char **ft_split(char const *s, char c);
** 
** Turn in files
** -
** 
** Parameters
** s: The string to be split.
** c: The delimiter character.
** 
** Return value
** The array of new strings resulting from the split.
** NULL if the allocation fails.
** External functs. malloc, free
** 
** Description
** Allocates (with malloc(3)) and returns an array
** of strings obtained by splitting ’s’ using the
** character ’c’ as a delimiter. The array must end
** with a NULL pointer.
*/

#include "libft.h"

static char	**ft_free(char **strs, int count)
{
	int	i;

	i = 0;
	while (i < count)
	{
		free(strs[i]);
		i++;
	}
	free (strs);
	return (NULL);
}

size_t	count_words(char const *str, char c)
{
	size_t	words;
	int		i;
	int		in_word;

	i = 0;
	words = 0;
	in_word = 0;
	while (str[i])
	{
		if (str[i] != c && in_word == 0)
		{
			words++;
			in_word = 1;
		}
		if (str[i] == c)
		{
			in_word = 0;
		}
		i++;
	}
	return (words);
}

size_t	next_word_pos(char const *s, char c, size_t i_pos, int mode)
{
	size_t	next_word_pos;

	next_word_pos = i_pos;
	if (mode == 1)
	{
		while (s[next_word_pos] == c && s[next_word_pos])
		{
			next_word_pos++;
		}
		return (next_word_pos);
	}
	else
	{
		while (s[next_word_pos] != c && s[next_word_pos])
		{
			next_word_pos++;
		}
		return (next_word_pos);
	}
}

char	*word_dup(const char *str, int start, int finish)
{
	char	*word;
	int		str_i;

	str_i = 0;
	word = malloc((finish - start + 1) * sizeof(char));
	if (!word)
		return (NULL);
	while (start < finish)
	{
		if (str[str_i] == '\'')
		{
			str_i++;
		}
		word[str_i++] = str[start++];
	}
	word[str_i] = '\0';
	return (word);
}

char	**ft_split(char const *s, char c)
{
	char	**result_lst;
	size_t	result_i1;
	size_t	s_i;
	size_t	next_word;

	result_i1 = 0;
	s_i = 0;
	next_word = 0;
	if (s == NULL)
		return (NULL);
	result_lst = (char **)malloc((count_words(s, c) + 1) * (sizeof(char *)));
	if (result_lst == NULL)
		return (NULL);
	while (result_i1 < count_words (s, c))
	{
		s_i = next_word_pos(s, c, s_i, 1);
		next_word = next_word_pos(s, c, s_i, 2);
		result_lst[result_i1] = word_dup(s, s_i, next_word);
		if (!result_lst[result_i1])
			return (ft_free(result_lst, result_i1), NULL);
		result_i1++;
		s_i = next_word;
	}
	result_lst[result_i1] = NULL;
	return (result_lst);
}

/*
size_t	ft_split_count(const char *s, char c)
{
	size_t	i;
	size_t	prev;
	size_t	next;
	size_t	size;
	size_t	counter;

	i = 0;
	prev = i;
	next = i;
	counter = 0;
	while (1)
	{
		if (s[i] == c || s[i] == '\0')
			next = i;
		size = next - prev;
		if (size > 1 || (size == 1 && s[i - 1] != c))
			counter++;
		if (s[i] == '\0')
			break ;
		prev = next;
		i++;
	}
	return (counter);
}
*/

/*
#include <stdio.h>

size_t	ft_strlen(const char *str)
{
	int	i;

	i = 0;
	while (str[i])
		i++;
	return (i);
}

void print_string_array(char **array)
{
    int i = 0;

    while (array[i] != NULL)
    {
        printf("String %d: %s\n", i, array[i]);
        i++;
    }
}

void test_ft_split(const char *input, char delimiter, int expected_count)
{
    char **result = ft_split(input, delimiter);
    int i;

    printf("Expected %d strings in split result:\n", expected_count);
    for (i = 0; i < expected_count; i++)
    {
        if (result[i] != NULL)
            printf("result[%d]: %s\n", i, result[i]);
        else
            printf("result[%d]: NULL (unexpected)\n", i);
    }

    if (result[expected_count] == NULL)
        printf("result[%d]: NULL (correct, end of array)\n", expected_count);
    else
        printf("result[%d]: %s (unexpected, should be NULL)\n", 
		expected_count, result[expected_count]);

    printf("\nTesting access beyond NULL terminator:\n");
    for (i = expected_count + 1; i < expected_count + 3; i++)
    {
        printf("Attempting to access result[%d]...\n", i);
        printf("result[%d]: %p (pointer should be inaccessible)\n",
		i, (void*)result[i]);
    }

    for (i = 0; i < expected_count && result[i] != NULL; i++)
    {
        free(result[i]);
    }
    free(result);
}

int main(void)
{
	char *test_str = "b11111b222222b3b4b5555b";
	char test_char = 'b';
	printf("Test String: %s\n", test_str);
	printf("Splits: %ld \n", count_words(test_str, test_char));

	printf("Start\n");
	int i = 0;
	while (i < ft_strlen(test_str))
	{
		printf("P: %ld ", next_word_pos(test_str, test_char, i, 1));
		i++;
	}
	printf("\n");

	printf("End\n");
	i = 0;
	while (i < ft_strlen(test_str))
	{
		printf("P: %ld ", next_word_pos(test_str, test_char, i, 2));
		i++;
	}
	printf("\n");

	print_string_array(ft_split(test_str, test_char));

	printf("\n\n\n");
	printf("Number of words: %ld\n", count_words("hello!", ' '));
    test_ft_split("hello!", ' ', 1);
	printf("\n\n\n");
	printf("Number of words: %ld\n", count_words("hello!\n12345", '\n'));
    test_ft_split("hello!\n12345", '\n', 2);
	printf("\n\n\n");
	printf("Number of words: %ld\n", count_words("hello!\0a12345", '\0'));
    test_ft_split("hello!\0a12345", '\0', 2);
	printf("\n\n\n");
	printf("Number of words: %ld\n", count_words("hello!\0a12345", '3'));
    test_ft_split("hello!\0a12345", '\0', 2);
	printf("\n\n\n");
	printf("Number of words: %ld\n", count_words("hello!-a ", ' '));
    test_ft_split("hello!-a ", ' ', 1);
	printf("\n\n\n");
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strchr.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 15:52:21 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/11 01:22:14 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        strchr, strrchr, strchrnul - locate character in string
** 
** SYNOPSIS
**        #include <string.h>
** 
**        char *strchr(const char *s, int c);
** 
**        char *strrchr(const char *s, int c);
** 
**        #define _GNU_SOURCE         See feature_test_macros(7)
**        #include <string.h>
** 
**        char *strchrnul(const char *s, int c);
*/

#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	size_t	i;
	char	cc;

	cc = (char) c;
	i = 0;
	while (s[i] != '\0')
	{
		if (s[i] == cc)
		{
			return ((char *)&s[i]);
		}
		i++;
	}
	if (s[i] == cc)
	{
		return ((char *)&s[i]);
	}
	return (NULL);
}

/*
#include <stdio.h>

int main()
{
    const char *test_strings[] = {
        "Hello, World!",
        "abc",
        "",
        "1234567890"
    };

    char test_chars[] = {'W', 'o', 'z', '\0', 'a', 'c', '1', '\0'};
    int num_tests = sizeof(test_chars) / sizeof(test_chars[0]);

    for (int i = 0; i < num_tests; i++)
    {
        const char *str = test_strings[i / 3];
        char c = test_chars[i];

        char *result = ft_strchr(str, c);
        char *expected = strchr(str, c);

        printf("Testing ft_strchr(\"%s\", '%c'):\n", str, c);
        if (result == expected)
        {
            printf("    Passed: Found at %s\n", result ? result : "NULL");
        }
        else
        {
            printf("    Failed: Expected %s but got %s\n", expected ?
			expected : "NULL", result ? result : "NULL");
        }
        printf("\n");
    }

	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strcmp.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/18 16:25:46 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 16:26:34 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_strcmp(const char *s1, const char *s2)
{
	size_t	i;

	i = 0;
	while (s1[i] != '\0' || s2[i] != '\0')
	{
		if (s1[i] != s2[i])
		{
			return ((unsigned char) s1[i] - (unsigned char)s2[i]);
		}
		i++;
	}
	return (0);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strdup.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 19:22:18 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 22:06:05 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        strdup, strndup, strdupa, strndupa - duplicate a string
** 
** SYNOPSIS
**        #include <string.h>
** 
**        char *strdup(const char *s);
** 
**        char *strndup(const char *s, size_t n);
**        char *strdupa(const char *s);
**        char *strndupa(const char *s, size_t n);
** 
**  Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
** 
**        strdup():
**            _XOPEN_SOURCE >= 500
**                || Since glibc 2.12: _POSIX_C_SOURCE >= 200809L
**                || Glibc versions <= 2.19: _BSD_SOURCE || _SVID_SOURCE
**        strndup():
**            Since glibc 2.10:
**                _POSIX_C_SOURCE >= 200809L
**            Before glibc 2.10:
**                _GNU_SOURCE
**        strdupa(), strndupa(): _GNU_SOURCE
*/

#include "libft.h"

char	*ft_strdup(const char *s)
{
	size_t	i;
	size_t	len;
	char	*dup;

	len = ft_strlen(s);
	dup = (char *) malloc((len + 1) * sizeof(char));
	if (!dup)
		return (NULL);
	i = 0;
	while (s[i])
	{
		dup[i] = s[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}

/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

int main()
{
    const char *str1 = "Hello, World!";
    char *dup1 = ft_strdup(str1);
    printf("Test 1: %s\n", (dup1 != NULL &&
	 strcmp(str1, dup1) == 0) ? "Passed" : "Failed");
    free(dup1);

    const char *str2 = "";
    char *dup2 = ft_strdup(str2);
    printf("Test 2: %s\n", (dup2 != NULL &&
strcmp(str2, dup2) == 0) ? "Passed" : "Failed");
    free(dup2);

    const char *str3 = "Line1\nLine2\tTabbed";
    char *dup3 = ft_strdup(str3);
    printf("Test 3: %s\n", (dup3 != NULL && 
	strcmp(str3, dup3) == 0) ? "Passed" : "Failed");
    free(dup3);

    const char *str4 = NULL;
    if (ft_strdup(str4) == NULL) 
        printf("Test 4: Passed\n");
    else
        printf("Test 4: Failed");

	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_striteri.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 14:57:34 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:20:11 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_striteri
** 
** Prototype
** void ft_striteri(char *s, void (*f)(unsigned int, char*));
** 
** Turn in files
** -
** 
** Parameters
** s: The string on which to iterate.
** f: The function to apply to each character.
** 
** Return value
** None
** 
** External functs.
** None
** 
** Description
** Applies the function ’f’ on each character of
** the string passed as argument, passing its index
** as first argument. Each character is passed by
** address to ’f’ to be modified if necessary.
*/

/*
void to_upper_even_in_place(unsigned int index, char *c) {
    if (index % 2 == 0 && *c >= 'a' && *c <= 'z')
        *c -= 32;
}
*/

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	unsigned int	i;

	i = 0;
	if (s == NULL || f == NULL)
	{
		return ;
	}
	while (s[i] != '\0')
	{
		f(i, &s[i]);
		i++;
	}
}

/*
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main()
{
	size_t test_number;
	char str[] = "HElllowdawdu";

	test_number = 0;

	printf("Test %zu\n", test_number);
	printf("Original %zu: %s, %s\n", test_number, str, "to_upper_even_in_place");

	ft_striteri(str, to_upper_even_in_place);
	printf("Result %zu: %s\n", test_number, str);

	test_number++;
	printf("-----------------------\n");

	char str2[] = "aaaaaaaaaaaaaaaaaaaaaaaaaa0000000
	00000000000ddddddddddddddddddddddddd";

	test_number = 0;

	printf("Test %zu\n", test_number);
	printf("Original %zu: %s, %s\n", test_number, str2
	 "to_upper_even_in_place");

	ft_striteri(str2, to_upper_even_in_place);
	printf("Result %zu: %s\n", test_number, str2);

	test_number++;
	printf("-----------------------\n");

	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strjoin.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 20:27:02 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 15:08:20 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_strjoin
** 
** Prototype
** char *ft_strjoin(char const *s1, char const *s2);
** 
** Turn in files
** -
** 
** Parameters
** s1: The prefix string.
** s2: The suffix string.
** 
** Return value
** The new string.
** NULL if the allocation fails.
** 
** External functs.
** malloc
** 
** Description
** Allocates (with malloc(3)) and returns a new
** string, which is t
*/

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	size_t	len_str1;
	size_t	len_str2;
	size_t	i;
	char	*joined_str;

	i = 0;
	if (s1 == NULL || s2 == NULL)
		return (NULL);
	len_str1 = ft_strlen(s1);
	len_str2 = ft_strlen(s2);
	joined_str = (char *)malloc((len_str1 + len_str2 + 1) * sizeof(char));
	if (joined_str == NULL)
		return (NULL);
	while (i < len_str1)
	{
		joined_str[i] = s1[i];
		i++;
	}
	while (i < (len_str1 + len_str2))
	{
		joined_str[i] = s2[i - len_str1];
		i++;
	}
	joined_str[i] = '\0';
	return (joined_str);
}

/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char *s1, *s2, *result;

    // Normal case
    s1 = "Hello, ";
    s2 = "World!";
    result = ft_strjoin(s1, s2);
    printf("Test 1: %s\n", (result != NULL && strcmp(result, 
	"Hello, World!") == 0) ? "Passed" : "Failed");
    free(result);

    // Empty prefix
    s1 = "";
    s2 = "World!";
    result = ft_strjoin(s1, s2);
    printf("Test 2: %s\n", (result != NULL && strcmp(result, "World!") 
	== 0) ? "Passed" : "Failed");
    free(result);

    // Empty suffix
    s1 = "Hello, ";
    s2 = "";
    result = ft_strjoin(s1, s2);
    printf("Test 3: %s\n", (result != NULL && strcmp(result, "Hello, ") 
	== 0) ? "Passed" : "Failed");
    free(result);

    // Both strings empty
    s1 = "";
    s2 = "";
    result = ft_strjoin(s1, s2);
    printf("Test 4: %s\n", (result != NULL && strcmp(result, "") 
	== 0) ? "Passed" : "Failed");
    free(result);

    s1 = "adsadsd da123";
    s2 = "456asd as as f";
    result = ft_strjoin(s1, s2);
    printf("Test 5: %s\n", result);
    free(result);
    return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strlcat.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 14:38:22 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 22:04:51 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**      strlcpy, strlcat — size-bounded string copying and concatenation
** 
** LIBRARY
**      Utility functions from BSD systems (libbsd, -lbsd)
** 
** SYNOPSIS
**      #include <string.h>
**      (See libbsd(7) for include usage.)
** 
**      size_t
**      strlcpy(char *dst, const char *src, size_t size);
** 
**      size_t
**      strlcat(char *dst, const char *src, size_t size);
*/

#include "libft.h"

/*
size_t ft_strlen(const char *str)
{
    size_t len = 0;

    while (str[len] != '\0')
        len++;
    return len;
}
*/

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	src_len;
	size_t	dst_len;

	i = 0;
	src_len = ft_strlen(src);
	dst_len = ft_strlen(dst);
	if (size <= dst_len)
		return (size + src_len);
	i = 0;
	while ((dst_len + i) < (size - 1) && (src[i] != '\0'))
	{
		dst[dst_len + i] = src[i];
		i++;
	}
	dst[dst_len + i] = '\0';
	return (src_len + dst_len);
}

/*
#include <stdio.h>

int main()
{
	char str1[] = "Test1234567890text for ft_strlcat function";
	char str2[] = "asdsffg....";
	printf("Src: %s\n", str1);

	// Function usage
	ft_strlcat(str2, str1, 8*sizeof(str2));

	printf("Dst: %s\n", str2);
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strlcpy.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 14:12:03 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 16:06:18 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**      strlcpy, strlcat — size-bounded string copying and concatenation
** 
** LIBRARY
**      Utility functions from BSD systems (libbsd, -lbsd)
** 
** SYNOPSIS
**      #include <string.h>
**      (See libbsd(7) for include usage.)
** 
**      size_t
**      strlcpy(char *dst, const char *src, size_t size);
** 
**      size_t
**      strlcat(char *dst, const char *src, size_t size);
*/

#include "libft.h"

/*
size_t ft_strlen(const char *str)
{
    size_t len = 0;

    while (str[len] != '\0')
        len++;
    return len;
}
*/

size_t	ft_strlcpy(char *dst, const char *src, size_t size)
{
	size_t	i;

	i = 0;
	if (size == 0)
		return (ft_strlen(src));
	while (src[i] != '\0' && i < (size - 1))
	{
		dst[i] = src[i];
		i++;
	}
	dst[i] = '\0';
	return (ft_strlen(src));
}

/*
#include <stdio.h>

int main()
{
	char str1[] = "Test1234567890text for ft_strlcpy function";
	char str2[100];
	printf("\nSource: %s\n", str1);

	// Function usage
	ft_strlcpy(str2, str1, sizeof(str2));

	printf("\nDestination using ft_strlcpy(): %s\n", str2);
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strlen.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 00:54:46 by goteixei          #+#    #+#             */
/*   Updated: 2024/10/24 00:54:46 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
//#include <stdlib.h> // Include standard library for memory allocation
//#include <stdio.h>  // Include for printf

size_t	ft_strlen(const char *str)
{
	int	i;

	i = 0;
	while (str[i])
		i++;
	return (i);
}

/*
#include "stdio.h"

int main()
{
	printf("String length: %d\n", ft_strlen("hello world"));
	return 0;
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strmapi.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 13:59:00 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 17:52:33 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_strmapi
** 
** Prototype
** char *ft_strmapi(char const *s, char (*f)(unsigned int, char));
** 
** Turn in files
** -
** 
** Parameters
** s: The string on which to iterate.
** f: The function to apply to each character.
** 
** Return value
** The string created from the successive applications of ’f’.
** Returns NULL if the allocation fails.
** 
** External functs.
** malloc
** 
** Description
** Applies the function f to each character of the
** string s, passing its index as the first argument
** and the character itself as the second. A new
** string is created (using malloc(3)) to collect the
** results from the successive applications of f.
*/

/*
char to_upper_even(unsigned int index, char c) {
    if (index % 2 == 0 && c >= 'a' && c <= 'z')
        return c - 32;
    return c;
}
*/

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	size_t	len;
	size_t	i;
	char	*result;

	len = 0;
	i = 0;
	if (s == NULL || f == NULL)
		return (NULL);
	while (s[len] != '\0')
		len++;
	result = (char *)malloc((len + 1) * sizeof(char));
	if (result == NULL)
		return (NULL);
	while (i < len)
	{
		result[i] = f(i, s[i]);
		i++;
	}
	result[i] = '\0';
	return (result);
}

/*
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main()
{
	size_t test_number;
	char *result;
	char *str;

	test_number = 0;
	str = "HElllowdawdu";

	printf("Test %s\n", test_number);
	printf("Original %d: %s, %s\n", test_number, str, "to_upper_even");

	result = ft_strmapi(str, to_upper_even);
	printf("Result %d: %s\n", test_number, result);

	test_number++;
	printf("-----------------------\n");


	return (0);
}
*/

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strncmp.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 16:35:49 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:15:33 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        strcmp, strncmp - compare two strings
** 
** SYNOPSIS
**        #include <string.h>
** 
**        int strcmp(const char *s1, const char *s2);
** 
**        int strncmp(const char *s1, const char *s2, size_t n);
*/

#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n && (s1[i] != '\0' || s2[i] != '\0'))
	{
		if (s1[i] != s2[i])
		{
			return ((unsigned char) s1[i] - (unsigned char)s2[i]);
		}
		i++;
	}
	return (0);
}

/*
#include <stdio.h>
#include <stddef.h>int	ft_strncmp(const char *s1, const  *s2, size_t n)


int main()
{
    const char *test1 = "Hello";
    const char *test2 = "Hello";
    const char *test3 = "Hello, World!";
    const char *test4 = "Hello";
    const char *test5 = "Hella";
    const char *test6 = "Hello";
    const char *test7 = "HelLo";
    const char *test8 = "Hell";
    const char *test9 = "Hello";
    const char *test10 = "Hello!";
    const char *test11 = "";
    const char *test12 = "Test";

    printf("Test 1: %d\n", ft_strncmp(test1, test2, 5));
    printf("Test 2: %d\n", ft_strncmp(test1, test3, 5));
    printf("Test 3: %d\n", ft_strncmp(test1, test4, 3));
    printf("Test 4: %d\n", ft_strncmp(test1, test5, 5));
    printf("Test 5: %d\n", ft_strncmp(test1, test6, 5));
    printf("Test 6: %d\n", ft_strncmp(test1, test7, 5));
    printf("Test 7: %d\n", ft_strncmp(test1, test8, 4));
    printf("Test 8: %d\n", ft_strncmp(test1, test9, 10));
    printf("Test 9: %d\n", ft_strncmp(test1, test10, 5));
    printf("Test 10: %d\n", ft_strncmp(test11, test12, 0));
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strnstr.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 17:59:22 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:18:01 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**      strnstr — locate a substring in a string
** 
** LIBRARY
**      Utility functions from BSD systems (libbsd, -lbsd)
** 
** SYNOPSIS
**      #include <string.h>
**      (See libbsd(7) for include usage.)
** 
**      char *
**      strnstr(const char *big, const char *little, size_t len);
*/

#include "libft.h"

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i1;
	size_t	i2;

	i1 = 0;
	i2 = 0;
	if (*little == '\0')
		return ((char *)big);
	while (big[i1] != '\0' && i1 < len)
	{
		if (big[i1] == little[0])
		{
			i2 = 0;
			while ((little[i2] != '\0') && (little[i2] == big[i1 + i2])
				&& (i1 + i2) < len)
			{
				i2++;
			}
			if (little[i2] == '\0')
			{
				return ((char *)(big + i1));
			}
		}
		i1++;
	}
	return (NULL);
}

/*
#include <stdio.h>
#include <string.h>

int main()
{
    const char *haystack1 = "Hello, world!";
    const char *needle1 = "world";
    char *result = ft_strnstr(haystack1, needle1, strlen(haystack1));
    printf("Test 1: %s\n", result != NULL && result == 
	strstr(haystack1, needle1) ? "Passed" : "Failed");

    const char *haystack2 = "abcdef";
    const char *needle2 = "abc";
    result = ft_strnstr(haystack2, needle2, strlen(haystack2));
    printf("Test 2: %s\n", result != NULL && result == 
	strstr(haystack2, needle2) ? "Passed" : "Failed");

    const char *haystack3 = "abcdef";
    const char *needle3 = "def";
    result = ft_strnstr(haystack3, needle3, strlen(haystack3));
    printf("Test 3: %s\n", result != NULL && result == 
	strstr(haystack3, needle3) ? "Passed" : "Failed");

    const char *haystack4 = "abcdef";
    const char *needle4 = "xyz";
    result = ft_strnstr(haystack4, needle4, strlen(haystack4));
    printf("Test 4: %s\n", result == NULL ? "Passed" : "Failed");

    const char *haystack5 = "abcdef";
    const char *needle5 = "cde";
    result = ft_strnstr(haystack5, needle5, 4);
    printf("Test 5: %s\n", result == NULL ? "Passed" : "Failed");

    const char *haystack6 = "abcdef";
    const char *needle6 = "";
    result = ft_strnstr(haystack6, needle6, strlen(haystack6));
    printf("Test 6: %s\n", result != NULL && 
	result == haystack6 ? "Passed" : "Failed");

    const char *haystack7 = "";
    const char *needle7 = "a";
    result = ft_strnstr(haystack7, needle7, strlen(haystack7));
    printf("Test 7: %s\n", result == NULL ? "Passed" : "Failed");

    const char *haystack8 = "short";
    const char *needle8 = "shorter";
    result = ft_strnstr(haystack8, needle8, 10);
    printf("Test 8: %s\n", result == NULL ? "Passed" : "Failed");

	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strrchr.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 16:14:45 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/08 22:08:01 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        strchr, strrchr, strchrnul - locate character in string
** 
** SYNOPSIS
**        #include <string.h>
** 
**        char *strchr(const char *s, int c);
** 
**        char *strrchr(const char *s, int c);
** 
**        #define _GNU_SOURCE         See feature_test_macros(7)
**        #include <string.h>
** 
**        char *strchrnul(const char *s, int c);
*/

#include "libft.h"

char	*ft_strrchr(const char *s, int c)
{
	unsigned int	i;
	char			cc;
	char			*res;

	i = 0;
	cc = (char) c;
	res = NULL;
	while (s[i])
	{
		if (s[i] == cc)
		{
			res = (char *) &s[i];
		}
		i++;
	}
	if (s[i] == cc)
		res = (char *) &s[i];
	return (res);
}

/*
#include <stdio.h>

int main()
{
    const char *test_strings[] = {
        "Hello, World!",
        "abc",
        "",
        "1234567890"
    };

    char test_chars[] = {'W', 'o', 'z', '\0', 'a', 'c', '1', '\0'};
    int num_tests = sizeof(test_chars) / sizeof(test_chars[0]);

    for (int i = 0; i < num_tests; i++)
    {
        const char *str = test_strings[i / 3];
        char c = test_chars[i];

        char *result = ft_strrchr(str, c);
        char *expected = strrchr(str, c);

        printf("Testing ft_strchr(\"%s\", '%c'):\n", str, c);
        if (result == expected)
        {
            printf("    Passed: Found at %s\n", result ? result : "NULL");
        }
        else
        {
            printf("    Failed: Expected %s but got %s\n", expected ?
			expected : "NULL", result ? result : "NULL");
        }
        printf("\n");
    }

	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_strtrim.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 20:44:56 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:08:53 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Function name
** ft_strtrim
** 
** Prototype
** char *ft_strtrim(char const *s1, char const *set);
** 
** Turn in files
** -
** 
** Parameters
** s1: The string to be trimmed.
** set: The reference set of characters to trim.
** 
** Return value
** The trimmed string.
** NULL if the allocation fails.
** 
** External functs.
** malloc
** 
** Description
** Allocates (with malloc(3)) and returns a copy of
** ’s1’ with the characters specified in ’set’ removed
** from the beginning and the end of the string.
*/

#include "libft.h"

int	ft_char_in_set(char c, char const *set)
{
	size_t	i;

	i = 0;
	while (set[i])
	{
		if (set[i] == c)
			return (1);
		i++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	char	*str;
	size_t	start;
	size_t	end;
	size_t	i;

	i = 0;
	start = 0;
	while ((s1[i] != '\0') && (ft_char_in_set(s1[start], set) == 1))
		start++;
	end = ft_strlen(s1);
	while (end > start && ft_char_in_set(s1[end - 1], set))
		end--;
	str = (char *)malloc(sizeof(*s1) * (end - start + 1));
	if (!str)
		return (NULL);
	i = 0;
	while (start < end)
		str[i++] = s1[start++];
	str[i] = 0;
	return (str);
}

/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char *s1, *set, *result;

    // Normal case
    s1 = "   Hello, World!   ";
    set = " ";
    result = ft_strtrim(s1, set);
    printf("Test 1: '%s'\n", (result != NULL &&
	strcmp(result, "Hello, World!") == 0) ? "Passed" : "Failed");
    free(result);

    // Trimming with multiple characters
    s1 = "---Hello, World!---";
    set = "-";
    result = ft_strtrim(s1, set);
    printf("Test 2: '%s'\n", (result != NULL &&
	strcmp(result, "Hello, World!") == 0) ? "Passed" : "Failed");
    free(result);

    // Only trimming characters from the start
    s1 = "   Hello, World!";
    set = " ";
    result = ft_strtrim(s1, set);
    printf("Test 3: '%s'\n", (result != NULL &&
	strcmp(result, "Hello, World!") == 0) ? "Passed" : "Failed");
    free(result);

    // Only trimming characters from the end
    s1 = "Hello, World!   ";
    set = " ";
    result = ft_strtrim(s1, set);
    printf("Test 4: '%s'\n", (result != NULL &&
	strcmp(result, "Hello, World!") == 0) ? "Passed" : "Failed");
    free(result);

    // No characters to trim
    s1 = "Hello, World!";
    set = "xyz";
    result = ft_strtrim(s1, set);
    printf("Test 5: '%s'\n", (result != NULL &&
	strcmp(result, "Hello, World!") == 0) ? "Passed" : "Failed");
    free(result);

    // Trimming an empty string
    s1 = "";
    set = " ";
    result = ft_strtrim(s1, set);
    printf("Test 6: '%s'\n", (result != NULL &&
	strcmp(result, "") == 0) ? "Passed" : "Failed");
    free(result);

    // Trimming with NULL input
    result = ft_strtrim(NULL, set);
    printf("Test 7: %s\n", result == NULL ? "Passed" : "Failed");

    return 0;
}
*/

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_substr.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 19:36:39 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/04 01:07:56 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        strdup, strndup, strdupa, strndupa - duplicate a string
** 
** SYNOPSIS
**        #include <string.h>
** 
**        char *strdup(const char *s);
** 
**        char *strndup(const char *s, size_t n);
**        char *strdupa(const char *s);
**        char *strndupa(const char *s, size_t n);
*/

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char	*substr;
	size_t	i;
	size_t	str_len;

	if (s == NULL)
		return (NULL);
	str_len = ft_strlen(s);
	if (start >= str_len)
		return (ft_strdup(""));
	if (len > str_len - start)
		len = str_len - start;
	substr = (char *)malloc((len + 1) * sizeof(char));
	if (substr == NULL)
		return (NULL);
	i = 0;
	while (i < len)
	{
		substr[i] = s[start + i];
		i++;
	}
	substr[i] = '\0';
	return (substr);
}

/*
#include <stdio.h>

int main()
{
    char *s = "Hello, World!";
    char *substr;

    substr = ft_substr(s, 7, 5);
    printf("Test 1: %s\n", (substr != NULL &&
	strcmp(substr, "World") == 0) ? "Passed" : "Failed");
    free(substr);

    substr = ft_substr(s, 20, 5);
    printf("Test 2: %s\n", (substr != NULL &&
	strcmp(substr, "") == 0) ? "Passed" : "Failed");
    free(substr);

    substr = ft_substr(s, 7, 10);
    printf("Test 3: %s\n", (substr != NULL &&
	strcmp(substr, "World!") == 0) ? "Passed" : "Failed");
    free(substr);

    substr = ft_substr(s, 7, 0);
    printf("Test 4: %s\n", (substr != NULL &&
	strcmp(substr, "") == 0) ? "Passed" : "Failed");
    free(substr);

    substr = ft_substr(s, 0, strlen(s));
    printf("Test 5: %s\n", (substr != NULL &&
	strcmp(substr, s) == 0) ? "Passed" : "Failed");
    free(substr);

    return 0;
}
*/

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_tolower.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 15:41:25 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/10 23:54:35 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        toupper, tolower, toupper_l, tolower_l - convert uppercase or lowercase
** 
** SYNOPSIS
**        #include <ctype.h>
** 
**        int toupper(int c);
**        int tolower(int c);
** 
**        int toupper_l(int c, locale_t locale);
**        int tolower_l(int c, locale_t locale);
** 
**    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
** 
**        toupper_l(), tolower_l():
**            Since glibc 2.10:
**                   _XOPEN_SOURCE >= 700
**            Before glibc 2.10:
**                   _GNU_SOURCE
*/

#include "libft.h"

int	ft_tolower(int c)
{
	int	nb;
	int	nc;

	if (c >= 'A' && c <= 'Z')
	{
		nb = c - 'A';
		nc = 'a' + nb;
		return (nc);
	}
	else
	{
		return (c);
	}
	return (0);
}

/*
#include <stdio.h>

int main()
{
	char str1 = 'z';
	printf("Original: %c\n", str1);
	// Function usage
	int result1 = ft_tolower(str1);
	printf("Result: %c\n", result1);

	char str2 = 'F';
	printf("Original: %c\n", str2);
	// Function usage
	int result2 = ft_tolower(str2);
	printf("Result: %c\n", result2);

	char str3 = '9';
	printf("Original: %c\n", str3);
	// Function usage
	int result3 = ft_tolower(str3);
	printf("Result: %c\n", result3);

	char str4 = ' ';
	printf("Original: %c\n", str4);
	// Function usage
	int result4 = ft_tolower(str4);
	printf("Result: %c\n", result4);
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/ft_toupper.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 15:14:30 by goteixei          #+#    #+#             */
/*   Updated: 2024/11/10 23:55:11 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** NAME
**        toupper, tolower, toupper_l, tolower_l - convert uppercase or lowercase
** 
** SYNOPSIS
**        #include <ctype.h>
** 
**        int toupper(int c);
**        int tolower(int c);
** 
**        int toupper_l(int c, locale_t locale);
**        int tolower_l(int c, locale_t locale);
** 
**    Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
** 
**        toupper_l(), tolower_l():
**            Since glibc 2.10:
**                   _XOPEN_SOURCE >= 700
**            Before glibc 2.10:
**                   _GNU_SOURCE
*/

#include "libft.h"

int	ft_toupper(int c)
{
	int	nb;
	int	nc;

	if (c >= 'a' && c <= 'z')
	{
		nb = c - 'a';
		nc = 'A' + nb;
		return (nc);
	}
	else
	{
		return (c);
	}
	return (0);
}

/*
#include <stdio.h>

int main()
{
	char str1 = 'z';
	printf("Original: %c\n", str1);
	// Function usage
	int result1 = ft_toupper(str1);
	printf("Result: %c\n", result1);

	char str2 = 'F';
	printf("Original: %c\n", str2);
	// Function usage
	int result2 = ft_toupper(str2);
	printf("Result: %c\n", result2);

	char str3 = '9';
	printf("Original: %c\n", str3);
	// Function usage
	int result3 = ft_toupper(str3);
	printf("Result: %c\n", result3);

	char str4 = ' ';
	printf("Original: %c\n", str4);
	// Function usage
	int result4 = ft_toupper(str4);
	printf("Result: %c\n", result4);
	return (0);
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/get_next_line/get_next_line.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/20 19:21:16 by goteixei          #+#    #+#             */
/*   Updated: 2024/12/22 19:17:21 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

static char	*ft_next(char *buffer)
{
	int		buffer_i;
	int		line_i;
	char	*line;

	buffer_i = 0;
	line_i = 0;
	if (!buffer)
		return (free(buffer), NULL);
	while (buffer[buffer_i] && buffer[buffer_i] != '\n')
		buffer_i++;
	if (!buffer[buffer_i])
	{
		free(buffer);
		return (NULL);
	}
	line = (char *)malloc((ft_strlen(buffer) - buffer_i + 1) * sizeof(char));
	if (!line)
		return (free(buffer), NULL);
	buffer_i++;
	while (buffer[buffer_i])
	{
		line[line_i++] = buffer[buffer_i++];
	}
	line[line_i] = '\0';
	return (free(buffer), line);
}

static char	*ft_line(char *buffer)
{
	char	*line;
	int		i;

	i = 0;
	if (!buffer[i])
		return (free(buffer), NULL);
	while (buffer[i] && buffer[i] != '\n')
		i++;
	line = (char *)malloc(i + 2 * sizeof(char));
	if (!line)
		return (free(buffer), NULL);
	i = 0;
	while (buffer[i] && buffer[i] != '\n')
	{
		line[i] = buffer[i];
		i++;
	}
	if (buffer[i] && buffer[i] == '\n')
	{
		line[i] = '\n';
		i++;
	}
	line[i] = '\0';
	return (line);
}

static char	*read_file(int fd, char *res)
{
	char	*buffer;
	int		byte_read;

	if (!res)
		res = ft_calloc (1, 1);
	if (!res)
		return (NULL);
	buffer = (char *)malloc(BUFFER_SIZE + 1 * sizeof(char));
	if (!buffer)
		return (free(buffer), NULL);
	byte_read = 1;
	while (!ft_strchr(res, '\n') && byte_read > 0)
	{
		byte_read = read(fd, buffer, BUFFER_SIZE);
		if (byte_read == -1)
			return (free(buffer), free(res), NULL);
		buffer[byte_read] = '\0';
		res = ft_strjoin(res, buffer);
		if (!res)
			return (free(buffer), NULL);
	}
	free (buffer);
	return (res);
}

char	*get_next_line(int fd)
{
	static char	*buffer;
	char		*line;

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	buffer = read_file(fd, buffer);
	if (!buffer)
		return (NULL);
	if (buffer[0] == '\0')
	{
		free(buffer);
		buffer = NULL;
		return (NULL);
	}
	line = ft_line(buffer);
	if (!line)
		return (free(buffer), buffer = NULL, NULL);
	buffer = ft_next(buffer);
	return (line);
}

/* 
# include <stdlib.h>
# include <unistd.h>
#include <fcntl.h>
# include <stdio.h>

int	main(void)
{
	int		fd;
	int		count;
	char	*line;

	count = 0;
	fd = open("test.txt", O_RDONLY);
	//fd = 0;
	//fd = -1;
	if (fd == -1)
	{
		printf("Error opening file.");
		return (1);
	}

	printf("------------------------------------------");
	printf("\nStart of file reached or error occurred.\n\n");

	while (1)
	//while (count < 4)
	//while (line != NULL) //does this make the program not work
	{
		line = get_next_line(fd);
		if (line == NULL)
		{
			printf("\nEnd of file reached or error occurred.\n");
			printf("------------------------------------------");
			break ;
		}
		count++;
		printf("[%d]: %s\n", count, line);
		free(line);
		line = NULL;
		
	}
	close (fd);
	return (0);
} */


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/get_next_line/get_next_line.h
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 13:18:44 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/09 12:08:27 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
//#  define BUFFER_SIZE 42
//#  define BUFFER_SIZE 1
//#  define BUFFER_SIZE 10
#  define BUFFER_SIZE 1000000
# endif

// *malloc() free() read()
# include <stdlib.h>
# include <unistd.h>

# include "../libft.h"

char	*get_next_line(int fd);

/*
void	*ft_bzero(void *s, size_t len);
void	*ft_calloc(size_t nmemb, size_t size);
char	*ft_strchr(const char *s, int c);
char	*ft_strjoin(char *s1, char const *s2);
size_t	ft_strlen(const char *str);
*/

#endif


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/get_next_line/get_next_line_bonus.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_bonus.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/20 19:21:16 by goteixei          #+#    #+#             */
/*   Updated: 2024/12/23 10:54:30 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line_bonus.h"

static char	*ft_next(char *buffer)
{
	int		buffer_i;
	int		line_i;
	char	*line;

	buffer_i = 0;
	line_i = 0;
	if (!buffer)
		return (free(buffer), NULL);
	while (buffer[buffer_i] && buffer[buffer_i] != '\n')
		buffer_i++;
	if (!buffer[buffer_i])
	{
		free(buffer);
		return (NULL);
	}
	line = (char *)malloc((ft_strlen(buffer) - buffer_i + 1) * sizeof(char));
	if (!line)
		return (free(buffer), NULL);
	buffer_i++;
	while (buffer[buffer_i])
	{
		line[line_i++] = buffer[buffer_i++];
	}
	line[line_i] = '\0';
	return (free(buffer), line);
}

static char	*ft_line(char *buffer)
{
	char	*line;
	int		i;

	i = 0;
	if (!buffer[i])
		return (free(buffer), NULL);
	while (buffer[i] && buffer[i] != '\n')
		i++;
	line = (char *)malloc(i + 2 * sizeof(char));
	if (!line)
		return (free(buffer), NULL);
	i = 0;
	while (buffer[i] && buffer[i] != '\n')
	{
		line[i] = buffer[i];
		i++;
	}
	if (buffer[i] && buffer[i] == '\n')
	{
		line[i] = '\n';
		i++;
	}
	line[i] = '\0';
	return (line);
}

static char	*read_file(int fd, char *res)
{
	char	*buffer;
	int		byte_read;

	if (!res)
		res = ft_calloc (1, 1);
	if (!res)
		return (NULL);
	buffer = (char *)malloc(BUFFER_SIZE + 1 * sizeof(char));
	if (!buffer)
		return (free(buffer), NULL);
	byte_read = 1;
	while (!ft_strchr(res, '\n') && byte_read > 0)
	{
		byte_read = read(fd, buffer, BUFFER_SIZE);
		if (byte_read == -1)
			return (free(buffer), free(res), NULL);
		buffer[byte_read] = '\0';
		res = ft_strjoin(res, buffer);
		if (!res)
			return (free(buffer), NULL);
	}
	free (buffer);
	return (res);
}

char	*get_next_line(int fd)
{
	static char	*buffer[OPEN_MAX];
	char		*line;

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	buffer[fd] = read_file(fd, buffer[fd]);
	if (!buffer[fd])
		return (NULL);
	if (buffer[fd][0] == '\0')
	{
		free(buffer[fd]);
		buffer[fd] = NULL;
		return (NULL);
	}
	line = ft_line(buffer[fd]);
	if (!line)
		return (free(buffer[fd]), buffer[fd] = NULL, NULL);
	buffer[fd] = ft_next(buffer[fd]);
	return (line);
}

/*
# include <stdlib.h>
# include <unistd.h>
#include <fcntl.h>
# include <stdio.h>

int	main(void)
{
	const char *files[] = {"file1.txt", "file2.txt", "file3.txt"};
	int num_files = sizeof(files) / sizeof(files[0]);
	int fds[num_files];
	int eof_flags[num_files];
	int line_counts[num_files];
	char *line;
	int i;
	int files_remaining;

	for (i = 0; i < num_files; i++)
	{
		fds[i] = open(files[i], O_RDONLY);
		if (fds[i] < 0)
		{
			perror("Error opening file");
			while (--i >= 0) close(fds[i]);
			return 0;
		}
		eof_flags[i] = 0;
		line_counts[i] = 0; 
	}

	files_remaining = num_files;

	printf("===== Testing get_next_line Bonus =====\n");

	while (files_remaining > 0)
	{
		for (i = 0; i < num_files; i++)
		{
			if (!eof_flags[i])
			{
				line = get_next_line(fds[i]);
				if (line)
				{
					line_counts[i]++;
					printf("File%d (Line %d): %s", i + 1, line_counts[i], line);
					if (line[ft_strlen(line) - 1] != '\n')
						printf("\n");
					free(line);
				}
				else
				{
					printf("File%d: (EOF)\n", i + 1);
					eof_flags[i] = 1;
					files_remaining--;
				}
			}
		}
	}

	for (i = 0; i < num_files; i++)
		close(fds[i]);

	printf("===== End of Test =====\n");
}
*/


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/get_next_line/get_next_line_bonus.h
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_bonus.h                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/02 13:18:44 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/09 12:08:21 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef GET_NEXT_LINE_BONUS_H
# define GET_NEXT_LINE_BONUS_H

# ifndef BUFFER_SIZE
//#  define BUFFER_SIZE 42
//#  define BUFFER_SIZE 1
//#  define BUFFER_SIZE 10
#  define BUFFER_SIZE 1000000
# endif

# ifndef OPEN_MAX
#  define OPEN_MAX 1024  // A reasonable default value
# endif

// *malloc() free() read()
# include <stdlib.h>
# include <unistd.h>
//for OPEN_MAX
# include <limits.h>

char	*get_next_line(int fd);

//char	*ft_free(char *str1, char *str2);
//char	*ft_next(char *buffer);
//char	*ft_line(char *buffer);
//char	*read_file(int fd, char *res);

/*
void	*ft_bzero(void *s, size_t len);
void	*ft_calloc(size_t nmemb, size_t size);
char	*ft_strchr(const char *s, int c);
char	*ft_strjoin(char const *s1, char const *s2);
size_t	ft_strlen(const char *str);
*/

#endif

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/get_next_line/get_next_line_utils.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/30 14:12:09 by goteixei          #+#    #+#             */
/*   Updated: 2025/02/09 12:07:56 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

/*
void	*ft_bzero(void *s, size_t len)
{
	char	*p;

	p = (char *)s;
	while (len > 0)
	{
		p[len - 1] = '\0';
		len--;
	}
	return (s);
}

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	ptr = (void *)malloc(nmemb * size);
	if (!ptr)
		return (NULL);
	ft_bzero(ptr, nmemb * size);
	return (ptr);
}

char	*ft_strchr(const char *s, int c)
{
	size_t	i;
	char	cc;

	cc = (char) c;
	i = 0;
	while (s[i] != '\0')
	{
		if (s[i] == cc)
		{
			return ((char *)&s[i]);
		}
		i++;
	}
	if (s[i] == cc)
	{
		return ((char *)&s[i]);
	}
	return (NULL);
}

char	*ft_strjoin(char *s1, const char *s2)
{
	size_t	len_str1;
	size_t	len_str2;
	size_t	i;
	char	*joined_str;

	i = 0;
	if (s1 == NULL || s2 == NULL)
		return (NULL);
	len_str1 = ft_strlen(s1);
	len_str2 = ft_strlen(s2);
	joined_str = (char *)malloc((len_str1 + len_str2 + 1) * sizeof(char));
	if (joined_str == NULL)
		return (free(s1), NULL);
	while (i < len_str1)
	{
		joined_str[i] = s1[i];
		i++;
	}
	while (i < (len_str1 + len_str2))
	{
		joined_str[i] = s2[i - len_str1];
		i++;
	}
	joined_str[i] = '\0';
	return (free(s1), joined_str);
}

size_t	ft_strlen(const char *str)
{
	int	i;

	i = 0;
	while (str && str[i])
		i++;
	return (i);
}
*/

--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/get_next_line/get_next_line_utils_bonus.c
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/30 14:12:09 by goteixei          #+#    #+#             */
/*   Updated: 2024/12/22 19:15:07 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

void	*ft_bzero(void *s, size_t len)
{
	char	*p;

	p = (char *)s;
	while (len > 0)
	{
		p[len - 1] = '\0';
		len--;
	}
	return (s);
}

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	ptr = (void *)malloc(nmemb * size);
	if (!ptr)
		return (NULL);
	ft_bzero(ptr, nmemb * size);
	return (ptr);
}

char	*ft_strchr(const char *s, int c)
{
	size_t	i;
	char	cc;

	cc = (char) c;
	i = 0;
	while (s[i] != '\0')
	{
		if (s[i] == cc)
		{
			return ((char *)&s[i]);
		}
		i++;
	}
	if (s[i] == cc)
	{
		return ((char *)&s[i]);
	}
	return (NULL);
}

char	*ft_strjoin(char *s1, const char *s2)
{
	size_t	len_str1;
	size_t	len_str2;
	size_t	i;
	char	*joined_str;

	i = 0;
	if (s1 == NULL || s2 == NULL)
		return (NULL);
	len_str1 = ft_strlen(s1);
	len_str2 = ft_strlen(s2);
	joined_str = (char *)malloc((len_str1 + len_str2 + 1) * sizeof(char));
	if (joined_str == NULL)
		return (free(s1), NULL);
	while (i < len_str1)
	{
		joined_str[i] = s1[i];
		i++;
	}
	while (i < (len_str1 + len_str2))
	{
		joined_str[i] = s2[i - len_str1];
		i++;
	}
	joined_str[i] = '\0';
	return (free(s1), joined_str);
}

size_t	ft_strlen(const char *str)
{
	int	i;

	i = 0;
	while (str && str[i])
		i++;
	return (i);
}


--------------------------------------------------
FILE: ./../minishell/lib/libft_repo/libft/libft.h
--------------------------------------------------
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: goteixei <goteixei@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 10:08:54 by goteixei          #+#    #+#             */
/*   Updated: 2025/04/18 16:27:24 by goteixei         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LIBFT_H
# define LIBFT_H

# include <unistd.h>
# include <stdlib.h>
# include <limits.h>
# include <stdint.h>

# include "ft_printf/ft_printf.h"
# include "get_next_line/get_next_line.h"

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}	t_list;

/**************************************************************************
 **************************************************************************
 * LIBFT
 **************************************************************************
 **************************************************************************/

/**************************************************************************
 * Page 1
 **************************************************************************/

int			ft_isalpha(int c);
int			ft_isdigit(int c);
int			ft_isascii(int c);
int			ft_isalnum(int c);
int			ft_isprint(int c);
size_t		ft_strlen(const char *str);
void		*ft_memset(void *s, int c, size_t n);
void		*ft_bzero(void *s, size_t len);
void		*ft_memcpy(void *dest, const void *src, size_t n);
void		*ft_memmove(void *dest, const void *src, size_t n);
size_t		ft_strlcpy(char *dest, const char *src, size_t size);
size_t		ft_strlcat(char *dst, const char *src, size_t size);
int			ft_toupper(int c);
int			ft_tolower(int c);
char		*ft_strchr(const char *s, int c);
char		*ft_strrchr(const char *s, int c);
int			ft_strncmp(const char *s1, const char *s2, size_t n);
void		*ft_memchr(const void *s, int c, size_t n);
int			ft_memcmp(const void *s1, const void *s2, size_t n);
char		*ft_strnstr(const char *big, const char *little, size_t len);
int			ft_atoi(const char *nptr);
void		*ft_calloc(size_t nmemb, size_t size);
char		*ft_strdup(const char *s);

/**************************************************************************
 * Next Pages
 **************************************************************************/

char		*ft_substr(char const *s, unsigned int start, size_t len);
char		*ft_strjoin(char const *s1, char const *s2);
char		*ft_strtrim(char const *s1, char const *set);
char		**ft_split(char const *s, char c);
char		*ft_itoa(int n);
char		*ft_strmapi(char const *s, char (*f)(unsigned int, char));
void		ft_striteri(char *s, void (*f)(unsigned int, char*));
void		ft_putchar_fd(char c, int fd);
void		ft_putstr_fd(char *s, int fd);
void		ft_putendl_fd(char *s, int fd);
void		ft_putnbr_fd(int n, int fd);

/**************************************************************************
 * Bonus
 **************************************************************************/

t_list		*ft_lstnew(void *content);
void		ft_lstadd_front(t_list **lst, t_list *new);
int			ft_lstsize(t_list *lst);
t_list		*ft_lstlast(t_list *lst);
void		ft_lstadd_back(t_list **lst, t_list *new);
void		ft_lstdelone(t_list *lst, void (*del)(void*));
void		ft_lstclear(t_list **lst, void (*del)(void*));
void		ft_lstiter(t_list *lst, void (*f)(void *));
t_list		*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));

/**************************************************************************
 **************************************************************************
 * After LIBFT Project
 **************************************************************************
 **************************************************************************/

void		ft_putendl(const char *s);
void		ft_putstr(const char *s);
void		ft_putchar(const char c);

/**************************************************************************
 * MATH
 **************************************************************************/

float		ft_abs_float(float nbr);
float		ft_max_float(float a, float b);
float		ft_min_float(float a, float b);

/**************************************************************************
 * Conversion
 **************************************************************************/

int			ft_atoi_base(char *str, char *base);
long		ft_atol(const char *str);

/**************************************************************************
 * Errors
 **************************************************************************/

int			ft_error(const int error_code, char *error_message, int fd);

/**************************************************************************
 * OTHER
 **************************************************************************/
size_t		ft_split_count(const char *s, char c);
int			ft_convert_from_base(char *str, char *base);
int			ft_check_base_error(char *str);

int			ft_strcmp(const char *s1, const char *s2);

#endif

--------------------------------------------------
FILE: ./../minishell/Makefile
--------------------------------------------------
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jpedro-f <jpedro-f@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/03/17 15:55:38 by goteixei          #+#    #+#              #
#    Updated: 2025/05/21 13:01:22 by jpedro-f         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# --- Colors (for terminal output) ---
RESET			= $(shell printf "\33[0m")
RED				= $(shell printf "\33[31m")
GREEN			= $(shell printf "\33[32m")
WHITE			= $(shell printf "\33[37m")
YELLOW			= $(shell printf "\33[33m")
BLUE			= $(shell printf "\33[34m")

# --- Symbols / Emojis (requires UTF-8 terminal) ---
CHECKMARK		= ✅
CROSSMARK		= ❌
GEAR			= ⚙️
FOLDER			= 📁
SPARKLES		= ✨

# --- Program Name ---
NAME 			= minishell

# Directories
INC_DIR			= inc/
LIB_DIR			= lib/
SRC_DIR			= src/

# --- Libft Setup ---
# Directory where the Libft repository will be cloned
LIBFT_REPO_DIR	= $(LIB_DIR)libft_repo/
# Path to the actual Libft source code *inside* the cloned repository
LIBFT_SRC_DIR	= $(LIBFT_REPO_DIR)libft/
# Path to the compiled libft.a file (TARGET FILE)
LIBFT_A			= $(LIBFT_SRC_DIR)libft.a
# Libft Repository URL
LIBFT_REPO_URL	= https://github.com/goncalotr/42_libft_v2.git

# --- Source Directories ---
#MANDATORY_DIR	= $(SRC_DIR)mandatory/
# Using just SRC_DIR

# Libraries
LIBFT			= $(LIBFT_DIR)libft.a

# --- Compiler and Flags ---
CC				= cc
RM				= rm -rf
SAN_FLAGS		= -fsanitize=address
SAN_FLAGS		+= -fsanitize=leak
SAN_FLAGS		+= -fsanitize=undefined
SAN_FLAGS		+= -fno-omit-frame-pointer
CFLAGS			= -Wall -Wextra -Werror -g
#CFLAGS			+= $(SAN_FLAGS)
CFLAGS			+= -I$(INC_DIR)
CFLAGS			+= -I$(LIBFT_SRC_DIR)
CFLAGS			+= -I$(LIBFT_SRC_DIR)
LDFLAGS = $(SAN_FLAGS)

# -------------------------------------------------------------
# MANDATORY
# -------------------------------------------------------------

#MANDATORY_SRC	= $(MANDATORY_DIR)main.c
MANDATORY_SRC	= $(SRC_DIR)/signals/ms_signal_handlers.c\
				  $(SRC_DIR)/signals/ms_debug_global_signal.c\
				  $(SRC_DIR)/parsing/ms_parser_placeholder.c\
				  $(SRC_DIR)/syntax_check/ms_syntax_utils.c\
				  $(SRC_DIR)/syntax_check/ms_syntax_check.c\
				  $(SRC_DIR)/syntax_check/ms_debug_input.c\
				  $(SRC_DIR)/parsing/ms_parsing.c\
				  $(SRC_DIR)/parsing/ms_main_parsing.c\
				  $(SRC_DIR)/parsing/ms_parsing_utils.c\
				  $(SRC_DIR)/execution/ms_tree_exec.c\
				  $(SRC_DIR)/tokenization/ms_quotes.c\
				  $(SRC_DIR)/tokenization/ms_quotes_utils.c\
				  $(SRC_DIR)/tokenization/ms_quotes_off.c\
				  $(SRC_DIR)/tokenization/ms_tokenization.c\
				  $(SRC_DIR)/tokenization/ms_tokenization_utils.c\
				  $(SRC_DIR)/tokenization/ms_tokenization_utils2.c\
				  $(SRC_DIR)/tokenization/ms_list_utils.c\
				  $(SRC_DIR)/expand/ms_expand_var.c\
				  $(SRC_DIR)/expand/ms_expand_var_2.c\
				  $(SRC_DIR)/expand/ms_expand_var_utils.c\
				  $(SRC_DIR)/builtin/ms_execute_cd.c\
				  $(SRC_DIR)/builtin/ms_execute_echo.c\
				  $(SRC_DIR)/builtin/ms_execute_env.c\
				  $(SRC_DIR)/builtin/ms_execute_exit.c\
				  $(SRC_DIR)/builtin/ms_execute_export.c\
				  $(SRC_DIR)/builtin/ms_execute_pwd.c\
				  $(SRC_DIR)/builtin/ms_execute_unset.c\
				  $(SRC_DIR)/init/ms_init_struct.c\
				  $(SRC_DIR)/exec/ms_exec_external.c\
				  $(SRC_DIR)/exec/ms_path_handler.c\
				  $(SRC_DIR)/prompt/ms_prompt.c\
				  $(SRC_DIR)main.c

# Object files in the same directory as source
MANDATORY_OBJ	= $(MANDATORY_SRC:.c=.o)

# -------------------------------------------------------------
# MANDATORY
# RULES
# -------------------------------------------------------------

all:			$(NAME)

$(NAME):		$(LIBFT_A) $(MANDATORY_OBJ) 
				@echo "$(YELLOW)Compiling $(NAME) (Mandatory)...$(RESET)"
				@$(CC) $(CFLAGS) $(MANDATORY_OBJ) $(LIBFT_A) -o $(NAME) -lreadline
				@echo "$(GREEN)$(NAME) compiled successfully!$(RESET)"
				@echo "$(GREEN)+---------------------------------------------+"
				@echo "|                                             |"
				@echo "|       $(CHECKMARK) $(NAME) build successful!        |"
				@echo "|                                             |"
				@echo "+---------------------------------------------+$(RESET)"

$(LIBFT_A):
				@echo "$(RED)Libft library ($(LIBFT_A)) not found or needs update. Preparing Libft...$(RESET)"
				@echo "Removing old Libft repository clone (if any)..."
				@$(RM) $(LIBFT_REPO_DIR)
				@echo "Creating parent directory $(LIB_DIR)..."
				@mkdir -p $(LIB_DIR)
				@echo "Cloning $(LIBFT_REPO_URL) into $(LIBFT_REPO_DIR)...$(RESET)"
				@git clone --depth 1 $(LIBFT_REPO_URL) $(LIBFT_REPO_DIR) || (echo "$(RED)ERROR: Clone failed$(RESET)" && exit 1)
				@echo "$(YELLOW)Compiling Libft in $(LIBFT_SRC_DIR)...$(RESET)"
				@make -s -C $(LIBFT_SRC_DIR) > /dev/null || (echo "ERROR: Libft make failed" && exit 1)
				@echo "$(GREEN)Libft compiled successfully!$(RESET)"

# --- Cleaning Rules ---

clean:
				@echo "$(YELLOW)Object files cleaning start$(RESET)"
				@echo "Cleaning project objects..."
				@$(RM) $(MANDATORY_OBJ)
				@echo "Cleaning Libft objects (if possible)..."
				@-if [ -d "$(LIBFT_SRC_DIR)" ]; then make -s -C $(LIBFT_SRC_DIR) clean; fi
				@echo "$(GREEN)Object files cleaned successfully!$(RESET)"

fclean:			clean
				@echo "$(YELLOW)Executable files cleaning start$(RESET)"
				@echo "Cleaning executable $(NAME)..."
				@$(RM) $(NAME)
				@echo "Cleaning Libft library (if possible)..."
				@-if [ -d "$(LIBFT_SRC_DIR)" ]; then make -s -C $(LIBFT_SRC_DIR) fclean; fi
				@echo "Removing entire Libft repository clone directory $(LIBFT_REPO_DIR)..."
				@$(RM) $(LIBFT_REPO_DIR)
				@echo "$(GREEN)Clean complete.$(RESET)"

re:				fclean all

# --- Utility Rules ---

# Rule to force re-downloading libft
#update_libft:
#				@echo "$(YELLOW)Removing existing libft to force re-download...$(RESET)"
#				@rm -rf $(LIBFT_DIR)
#				@$(MAKE) $(LIBFT_CHECK_FILE)
#				@echo "$(GREEN)Use 'make' or 'make all' to recompile everything.$(RESET)"

# Rule to use valgrind
valgrind:		all
				@valgrind --leak-check=full --show-leak-kinds=all --track-fds=yes \
					--track-origins=yes --trace-children=yes --suppressions=readline.supp ./minishell

.PHONY:			all clean fclean re valgrind

#.SILENT


